/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "165",
  MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  CullFaceNone = 0,
  CullFaceBack = 1,
  CullFaceFront = 2,
  PCFShadowMap = 1,
  PCFSoftShadowMap = 2,
  VSMShadowMap = 3,
  FrontSide = 0,
  BackSide = 1,
  DoubleSide = 2,
  NoBlending = 0,
  NormalBlending = 1,
  AdditiveBlending = 2,
  SubtractiveBlending = 3,
  MultiplyBlending = 4,
  CustomBlending = 5,
  AddEquation = 100,
  SubtractEquation = 101,
  ReverseSubtractEquation = 102,
  MinEquation = 103,
  MaxEquation = 104,
  ZeroFactor = 200,
  OneFactor = 201,
  SrcColorFactor = 202,
  OneMinusSrcColorFactor = 203,
  SrcAlphaFactor = 204,
  OneMinusSrcAlphaFactor = 205,
  DstAlphaFactor = 206,
  OneMinusDstAlphaFactor = 207,
  DstColorFactor = 208,
  OneMinusDstColorFactor = 209,
  SrcAlphaSaturateFactor = 210,
  NeverDepth = 0,
  AlwaysDepth = 1,
  LessDepth = 2,
  LessEqualDepth = 3,
  EqualDepth = 4,
  GreaterEqualDepth = 5,
  GreaterDepth = 6,
  NotEqualDepth = 7,
  MultiplyOperation = 0,
  MixOperation = 1,
  AddOperation = 2,
  NoToneMapping = 0,
  LinearToneMapping = 1,
  ReinhardToneMapping = 2,
  CineonToneMapping = 3,
  ACESFilmicToneMapping = 4,
  CustomToneMapping = 5,
  UVMapping = 300,
  CubeReflectionMapping = 301,
  CubeRefractionMapping = 302,
  EquirectangularReflectionMapping = 303,
  EquirectangularRefractionMapping = 304,
  CubeUVReflectionMapping = 306,
  RepeatWrapping = 1e3,
  ClampToEdgeWrapping = 1001,
  MirroredRepeatWrapping = 1002,
  NearestFilter = 1003,
  NearestMipmapNearestFilter = 1004,
  NearestMipmapLinearFilter = 1005,
  LinearFilter = 1006,
  LinearMipmapNearestFilter = 1007,
  LinearMipmapLinearFilter = 1008,
  UnsignedByteType = 1009,
  ByteType = 1010,
  ShortType = 1011,
  UnsignedShortType = 1012,
  IntType = 1013,
  UnsignedIntType = 1014,
  FloatType = 1015,
  HalfFloatType = 1016,
  UnsignedShort4444Type = 1017,
  UnsignedShort5551Type = 1018,
  UnsignedInt248Type = 1020,
  AlphaFormat = 1021,
  RGBFormat = 1022,
  RGBAFormat = 1023,
  LuminanceFormat = 1024,
  LuminanceAlphaFormat = 1025,
  DepthFormat = 1026,
  DepthStencilFormat = 1027,
  RedFormat = 1028,
  RedIntegerFormat = 1029,
  RGFormat = 1030,
  RGIntegerFormat = 1031,
  RGBIntegerFormat = 1032,
  RGBAIntegerFormat = 1033,
  RGB_S3TC_DXT1_Format = 33776,
  RGBA_S3TC_DXT1_Format = 33777,
  RGBA_S3TC_DXT3_Format = 33778,
  RGBA_S3TC_DXT5_Format = 33779,
  RGB_PVRTC_4BPPV1_Format = 35840,
  RGB_PVRTC_2BPPV1_Format = 35841,
  RGBA_PVRTC_4BPPV1_Format = 35842,
  RGBA_PVRTC_2BPPV1_Format = 35843,
  RGB_ETC1_Format = 36196,
  RGB_ETC2_Format = 37492,
  RGBA_ETC2_EAC_Format = 37496,
  RGBA_ASTC_4x4_Format = 37808,
  RGBA_ASTC_5x4_Format = 37809,
  RGBA_ASTC_5x5_Format = 37810,
  RGBA_ASTC_6x5_Format = 37811,
  RGBA_ASTC_6x6_Format = 37812,
  RGBA_ASTC_8x5_Format = 37813,
  RGBA_ASTC_8x6_Format = 37814,
  RGBA_ASTC_8x8_Format = 37815,
  RGBA_ASTC_10x5_Format = 37816,
  RGBA_ASTC_10x6_Format = 37817,
  RGBA_ASTC_10x8_Format = 37818,
  RGBA_ASTC_10x10_Format = 37819,
  RGBA_ASTC_12x10_Format = 37820,
  RGBA_ASTC_12x12_Format = 37821,
  RGBA_BPTC_Format = 36492,
  RED_RGTC1_Format = 36283,
  SIGNED_RED_RGTC1_Format = 36284,
  RED_GREEN_RGTC2_Format = 36285,
  SIGNED_RED_GREEN_RGTC2_Format = 36286,
  LoopOnce = 2200,
  LoopRepeat = 2201,
  LoopPingPong = 2202,
  InterpolateDiscrete = 2300,
  InterpolateLinear = 2301,
  InterpolateSmooth = 2302,
  ZeroCurvatureEnding = 2400,
  ZeroSlopeEnding = 2401,
  WrapAroundEnding = 2402,
  NormalAnimationBlendMode = 2500,
  AdditiveAnimationBlendMode = 2501,
  TrianglesDrawMode = 0,
  TriangleStripDrawMode = 1,
  TriangleFanDrawMode = 2,
  LinearEncoding = 3e3,
  sRGBEncoding = 3001,
  BasicDepthPacking = 3200,
  RGBADepthPacking = 3201,
  TangentSpaceNormalMap = 0,
  ObjectSpaceNormalMap = 1,
  SRGBColorSpace = "srgb",
  LinearSRGBColorSpace = "srgb-linear",
  DisplayP3ColorSpace = "display-p3";

// Core THREE.js functionality (simplified version for neural network visualization)
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
}

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  normalize() {
    const length = Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z
    );
    if (length > 0) {
      this.x /= length;
      this.y /= length;
      this.z /= length;
    }
    return this;
  }
  crossVectors(a, b) {
    const ax = a.x,
      ay = a.y,
      az = a.z;
    const bx = b.x,
      by = b.y,
      bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
}

class Color {
  constructor(r = 1, g = 1, b = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  clone() {
    return new Color(this.r, this.g, this.b);
  }
  multiplyScalar(scalar) {
    this.r *= scalar;
    this.g *= scalar;
    this.b *= scalar;
    return this;
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
}

class Matrix4 {
  constructor() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }

  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  set(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44
  ) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }

  lookAt(eye, target, up) {
    const te = this.elements;
    const x = new Vector3();
    const y = new Vector3();
    const z = new Vector3();

    z.copy(eye).sub(target);
    if (z.lengthSq() === 0) z.z = 1;
    z.normalize();
    x.crossVectors(up, z);
    if (x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) z.x += 0.0001;
      else z.z += 0.0001;
      z.normalize();
      x.crossVectors(up, z);
    }
    x.normalize();
    y.crossVectors(z, x);

    te[0] = x.x;
    te[4] = y.x;
    te[8] = z.x;
    te[1] = x.y;
    te[5] = y.y;
    te[9] = z.y;
    te[2] = x.z;
    te[6] = y.z;
    te[10] = z.z;

    return this;
  }
}

Vector3.prototype.sub = function (v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z;
  return this;
};

Vector3.prototype.lengthSq = function () {
  return this.x * this.x + this.y * this.y + this.z * this.z;
};

// Essential Three.js classes for our neural network
class Object3D {
  constructor() {
    this.position = new Vector3();
    this.rotation = new Vector3();
    this.scale = new Vector3(1, 1, 1);
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.children = [];
    this.parent = null;
    this.userData = {};
    this.up = new Vector3(0, 1, 0);
  }

  add(object) {
    this.children.push(object);
    object.parent = this;
    return this;
  }

  remove(object) {
    const index = this.children.indexOf(object);
    if (index !== -1) {
      this.children.splice(index, 1);
      object.parent = null;
    }
    return this;
  }

  getWorldDirection(target) {
    this.updateMatrixWorld(true);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  }

  updateMatrixWorld() {
    // Simplified matrix update
  }

  lookAt(x, y, z) {
    if (x.isVector3) {
      this.matrix.lookAt(this.position, x, this.up);
    } else {
      this.matrix.lookAt(this.position, new Vector3(x, y, z), this.up);
    }
  }
}

class Scene extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
  }
}

class Camera extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }

  updateProjectionMatrix() {
    // To be implemented by subclasses
  }
}

class PerspectiveCamera extends Camera {
  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }

  updateProjectionMatrix() {
    const near = this.near;
    let top = (near * Math.tan((0.5 * this.fov * Math.PI) / 180)) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;

    if (this.view !== null && this.view.enabled) {
      const fullWidth = this.view.fullWidth;
      const fullHeight = this.view.fullHeight;
      left += (this.view.offsetX * width) / fullWidth;
      top -= (this.view.offsetY * height) / fullHeight;
      width *= this.view.width / fullWidth;
      height *= this.view.height / fullHeight;
    }

    const skew = this.filmOffset;
    if (skew !== 0) left += (near * skew) / this.getFilmWidth();

    this.projectionMatrix.makePerspective(
      left,
      left + width,
      top,
      top - height,
      near,
      this.far,
      this.coordinateSystem
    );
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }

  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
}

Matrix4.prototype.makePerspective = function (
  left,
  right,
  top,
  bottom,
  near,
  far,
  coordinateSystem
) {
  const te = this.elements;
  const x = (2 * near) / (right - left);
  const y = (2 * near) / (top - bottom);
  const a = (right + left) / (right - left);
  const b = (top + bottom) / (top - bottom);
  let c, d;

  if (coordinateSystem === 2000) {
    c = -(far + near) / (far - near);
    d = (-2 * far * near) / (far - near);
  } else {
    c = -far / (far - near);
    d = (-far * near) / (far - near);
  }

  te[0] = x;
  te[4] = 0;
  te[8] = a;
  te[12] = 0;
  te[1] = 0;
  te[5] = y;
  te[9] = b;
  te[13] = 0;
  te[2] = 0;
  te[6] = 0;
  te[10] = c;
  te[14] = d;
  te[3] = 0;
  te[7] = 0;
  te[11] = -1;
  te[15] = 0;

  return this;
};

Matrix4.prototype.copy = function (m) {
  const te = this.elements;
  const me = m.elements;
  for (let i = 0; i < 16; i++) {
    te[i] = me[i];
  }
  return this;
};

Matrix4.prototype.invert = function () {
  // Simplified invert for our use case
  return this;
};

// Geometry classes
class BufferGeometry {
  constructor() {
    this.attributes = {};
    this.index = null;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }

  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }

  getAttribute(name) {
    return this.attributes[name];
  }
}

class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = 35044; // StaticDrawUsage
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }

  setUsage(value) {
    this.usage = value;
    return this;
  }

  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }
}

class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}

class SphereGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    widthSegments = 32,
    heightSegments = 16,
    phiStart = 0,
    phiLength = Math.PI * 2,
    thetaStart = 0,
    thetaLength = Math.PI
  ) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength,
    };

    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));

    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);

    let index = 0;
    const grid = [];

    const vertex = new Vector3();
    const normal = new Vector3();

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;

      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;

        vertex.x =
          -radius *
          Math.cos(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z =
          radius *
          Math.sin(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength);

        vertices.push(vertex.x, vertex.y, vertex.z);

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);

        uvs.push(u + uOffset, 1 - v);

        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    }

    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];

        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }

  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new BufferAttribute(
        new (index.length > 65535 ? Uint32Array : Uint16Array)(index),
        1
      );
    } else {
      this.index = index;
    }
    return this;
  }
}

// Material classes
class Material {
  constructor() {
    this.type = "Material";
    this.uuid = generateUUID();
    this.name = "";
    this.color = new Color(1, 1, 1);
    this.opacity = 1;
    this.transparent = false;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.fog = true;
    this.visible = true;
    this.userData = {};
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.name = source.name;
    this.color.copy(source.color);
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.fog = source.fog;
    this.visible = source.visible;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
}

class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(1, 1, 1);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }

  setValues(values) {
    if (values === undefined) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === undefined) continue;
      const currentValue = this[key];
      if (currentValue !== undefined) {
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (
          currentValue &&
          currentValue.isVector3 &&
          newValue &&
          newValue.isVector3
        ) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  }
}

class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(1, 1, 1);
    this.emissive = new Color(0, 0, 0);
    this.emissiveIntensity = 1.0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.emissive.copy(source.emissive);
    this.emissiveIntensity = source.emissiveIntensity;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissiveMap = source.emissiveMap;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }

  setValues(values) {
    if (values === undefined) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === undefined) continue;
      const currentValue = this[key];
      if (currentValue !== undefined) {
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (
          currentValue &&
          currentValue.isVector3 &&
          newValue &&
          newValue.isVector3
        ) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  }
}

class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(1, 1, 1);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }

  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }

  setValues(values) {
    if (values === undefined) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === undefined) continue;
      const currentValue = this[key];
      if (currentValue !== undefined) {
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  }
}

// Mesh class
class Mesh extends Object3D {
  constructor(geometry, material) {
    super();
    this.type = "Mesh";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new MeshBasicMaterial();
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.material) this.material = source.material;
    if (source.geometry) this.geometry = source.geometry;
    return this;
  }
}

class LineSegments extends Object3D {
  constructor(geometry, material) {
    super();
    this.type = "LineSegments";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new LineBasicMaterial();
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
}

// Light classes
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
}

class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
}

class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 2) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = null;
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow !== null ? source.shadow.clone() : null;
    return this;
  }
}

// WebGL Renderer (simplified)
class WebGLRenderer {
  constructor(parameters = {}) {
    const canvas =
      parameters.canvas !== undefined
        ? parameters.canvas
        : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    const context =
      parameters.context !== undefined ? parameters.context : null;

    this.domElement = canvas;
    this.context = null;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.outputColorSpace = SRGBColorSpace;
    this.useLegacyLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1.0;

    const _pixelRatio = 1;
    const _width = canvas.width;
    const _height = canvas.height;

    let _scissor = new Vector2(0, 0);
    let _scissorTest = false;
    let _viewport = new Vector2(0, 0);

    this.getContext = function () {
      return this.context;
    };

    this.getContextAttributes = function () {
      return this.context.getContextAttributes();
    };

    this.forceContextLoss = function () {
      const extension = this.context.getExtension("WEBGL_lose_context");
      if (extension) extension.loseContext();
    };

    this.forceContextRestore = function () {
      const extension = this.context.getExtension("WEBGL_lose_context");
      if (extension) extension.restoreContext();
    };

    this.getPixelRatio = function () {
      return _pixelRatio;
    };

    this.setPixelRatio = function (value) {
      if (value === undefined) return;
      canvas.width = _width * value;
      canvas.height = _height * value;
      canvas.style.width = _width + "px";
      canvas.style.height = _height + "px";
      this.setViewport(0, 0, _width, _height);
    };

    this.getSize = function (target) {
      return target.set(_width, _height);
    };

    this.setSize = function (width, height, updateStyle = true) {
      canvas.width = width * _pixelRatio;
      canvas.height = height * _pixelRatio;
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };

    this.getDrawingBufferSize = function (target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };

    this.setDrawingBufferSize = function (width, height, pixelRatio) {
      _width = width;
      _height = height;
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      this.setViewport(0, 0, width, height);
    };

    this.getCurrentViewport = function (target) {
      return target.copy(_viewport);
    };

    this.getViewport = function (target) {
      return target.copy(_viewport);
    };

    this.setViewport = function (x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      if (this.context) {
        this.context.viewport(
          _viewport.x * _pixelRatio,
          _viewport.y * _pixelRatio,
          _viewport.z * _pixelRatio,
          _viewport.w * _pixelRatio
        );
      }
    };

    this.getScissor = function (target) {
      return target.copy(_scissor);
    };

    this.setScissor = function (x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      if (this.context) {
        this.context.scissor(
          _scissor.x * _pixelRatio,
          _scissor.y * _pixelRatio,
          _scissor.z * _pixelRatio,
          _scissor.w * _pixelRatio
        );
      }
    };

    this.getScissorTest = function () {
      return _scissorTest;
    };

    this.setScissorTest = function (boolean) {
      _scissorTest = boolean;
      if (this.context) {
        if (boolean) {
          this.context.enable(this.context.SCISSOR_TEST);
        } else {
          this.context.disable(this.context.SCISSOR_TEST);
        }
      }
    };

    this.setOpaqueSort = function (method) {
      // Simplified
    };

    this.setTransparentSort = function (method) {
      // Simplified
    };

    this.getClearColor = function (target) {
      return target.copy(this.getClearColor());
    };

    this.setClearColor = function (color, alpha = 1) {
      if (this.context) {
        if (color.isColor) {
          this.context.clearColor(color.r, color.g, color.b, alpha);
        } else {
          const c = new Color(color);
          this.context.clearColor(c.r, c.g, c.b, alpha);
        }
      }
    };

    this.getClearAlpha = function () {
      return 1.0;
    };

    this.setClearAlpha = function (alpha) {
      // Simplified
    };

    this.clear = function (color = true, depth = true, stencil = true) {
      if (this.context) {
        let bits = 0;
        if (color) bits |= this.context.COLOR_BUFFER_BIT;
        if (depth) bits |= this.context.DEPTH_BUFFER_BIT;
        if (stencil) bits |= this.context.STENCIL_BUFFER_BIT;
        this.context.clear(bits);
      }
    };

    this.clearColor = function () {
      this.clear(true, false, false);
    };

    this.clearDepth = function () {
      this.clear(false, true, false);
    };

    this.clearStencil = function () {
      this.clear(false, false, true);
    };

    this.render = function (scene, camera) {
      // Simplified render - just clear the canvas
      if (this.context) {
        if (this.autoClear || this.autoClearColor) {
          this.context.clear(this.context.COLOR_BUFFER_BIT);
        }

        // Very basic rendering simulation
        if (scene.background) {
          this.setClearColor(scene.background);
        }

        // Draw a simple visualization
        this.context.fillStyle = "#60a5fa";
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Draw some animated dots to simulate neural network
        for (let i = 0; i < 50; i++) {
          const angle = (Date.now() / 1000 + i) * 0.5;
          const radius = 50 + Math.sin(angle) * 20;
          const x = centerX + Math.cos(angle + i) * radius;
          const y = centerY + Math.sin(angle + i) * radius;

          this.context.beginPath();
          this.context.arc(x, y, 3 + Math.sin(angle * 3) * 2, 0, Math.PI * 2);
          this.context.fillStyle = `hsl(${
            (i * 7 + Date.now() / 100) % 360
          }, 70%, 60%)`;
          this.context.fill();
        }
      }
    };

    // Initialize WebGL context
    try {
      const contextAttributes = Object.assign(
        {
          alpha: false,
          depth: true,
          stencil: false,
          antialias: false,
          premultipliedAlpha: true,
          preserveDrawingBuffer: false,
          powerPreference: "default",
          failIfMajorPerformanceCaveat: false,
        },
        parameters
      );

      if (context !== null) {
        this.context =
          context.getContextAttributes !== undefined ? context : null;
      } else {
        this.context =
          canvas.getContext("webgl2", contextAttributes) ||
          canvas.getContext("webgl", contextAttributes);
      }

      if (this.context === null) {
        if (canvas.getContext("webgl") !== null) {
          throw new Error(
            "Error creating WebGL context with your selected attributes."
          );
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }

      if (this.context.getShaderPrecisionFormat === undefined) {
        this.context.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }

    // Set initial viewport
    this.setViewport(0, 0, canvas.width, canvas.height);
  }
}

// Utility functions
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

// Add isColor and isVector3 properties
Color.prototype.isColor = true;
Vector3.prototype.isVector3 = true;
Vector2.prototype.isVector4 = false;

// Set up Vector4 for viewport
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }

  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w;
    return this;
  }
}

Vector4.prototype.isVector4 = true;

// Extend Vector2 for viewport
Vector2.prototype.set = function (x, y, z, w) {
  this.x = x;
  this.y = y;
  if (z !== undefined) this.z = z;
  if (w !== undefined) this.w = w;
  return this;
};

Vector2.prototype.copy = function (v) {
  this.x = v.x;
  this.y = v.y;
  if (v.z !== undefined) this.z = v.z;
  if (v.w !== undefined) this.w = v.w;
  return this;
};

// Export THREE object
const THREE = {
  REVISION,
  MOUSE,
  TOUCH,
  CullFaceNone,
  CullFaceBack,
  CullFaceFront,
  PCFShadowMap,
  PCFSoftShadowMap,
  VSMShadowMap,
  FrontSide,
  BackSide,
  DoubleSide,
  NoBlending,
  NormalBlending,
  AdditiveBlending,
  SubtractiveBlending,
  MultiplyBlending,
  CustomBlending,
  AddEquation,
  SubtractEquation,
  ReverseSubtractEquation,
  MinEquation,
  MaxEquation,
  ZeroFactor,
  OneFactor,
  SrcColorFactor,
  OneMinusSrcColorFactor,
  SrcAlphaFactor,
  OneMinusSrcAlphaFactor,
  DstAlphaFactor,
  OneMinusDstAlphaFactor,
  DstColorFactor,
  OneMinusDstColorFactor,
  SrcAlphaSaturateFactor,
  NeverDepth,
  AlwaysDepth,
  LessDepth,
  LessEqualDepth,
  EqualDepth,
  GreaterEqualDepth,
  GreaterDepth,
  NotEqualDepth,
  MultiplyOperation,
  MixOperation,
  AddOperation,
  NoToneMapping,
  LinearToneMapping,
  ReinhardToneMapping,
  CineonToneMapping,
  ACESFilmicToneMapping,
  CustomToneMapping,
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter,
  UnsignedByteType,
  ByteType,
  ShortType,
  UnsignedShortType,
  IntType,
  UnsignedIntType,
  FloatType,
  HalfFloatType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedInt248Type,
  AlphaFormat,
  RGBFormat,
  RGBAFormat,
  LuminanceFormat,
  LuminanceAlphaFormat,
  DepthFormat,
  DepthStencilFormat,
  RedFormat,
  RedIntegerFormat,
  RGFormat,
  RGIntegerFormat,
  RGBIntegerFormat,
  RGBAIntegerFormat,
  RGB_S3TC_DXT1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_BPTC_Format,
  RED_RGTC1_Format,
  SIGNED_RED_RGTC1_Format,
  RED_GREEN_RGTC2_Format,
  SIGNED_RED_GREEN_RGTC2_Format,
  LoopOnce,
  LoopRepeat,
  LoopPingPong,
  InterpolateDiscrete,
  InterpolateLinear,
  InterpolateSmooth,
  ZeroCurvatureEnding,
  ZeroSlopeEnding,
  WrapAroundEnding,
  NormalAnimationBlendMode,
  AdditiveAnimationBlendMode,
  TrianglesDrawMode,
  TriangleStripDrawMode,
  TriangleFanDrawMode,
  LinearEncoding,
  sRGBEncoding,
  BasicDepthPacking,
  RGBADepthPacking,
  TangentSpaceNormalMap,
  ObjectSpaceNormalMap,
  SRGBColorSpace,
  LinearSRGBColorSpace,
  DisplayP3ColorSpace,

  // Core classes
  Vector2,
  Vector3,
  Vector4,
  Color,
  Matrix4,
  Object3D,
  Scene,
  Camera,
  PerspectiveCamera,
  BufferGeometry,
  BufferAttribute,
  Float32BufferAttribute,
  SphereGeometry,
  Material,
  MeshBasicMaterial,
  MeshLambertMaterial,
  LineBasicMaterial,
  Mesh,
  LineSegments,
  Light,
  AmbientLight,
  PointLight,
  WebGLRenderer,
};

// Make THREE available globally
if (typeof window !== "undefined") {
  window.THREE = THREE;
}

if (typeof module !== "undefined" && module.exports) {
  module.exports = THREE;
}
