<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SNN Visualizer — SYNTHETIC-2</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--bg:#0a0c12;--panel:#12151c;--text:#c4d1e0;--muted:#6b7280;--edge:#1e293b;--edgeHot:#3b82f6;--node:#60a5fa;--hot:#f59e0b;--pulse:#ef4444}
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.5 Inter,system-ui,Helvetica,Arial;overflow:hidden}
    canvas{display:block}
    #overlay{pointer-events:none;position:fixed;inset:0;background:
      radial-gradient(1400px 900px at 30% 0%, #1e293b22, transparent 70%),
      radial-gradient(1000px 600px at 80% 100%, #1e1b4b22, transparent 60%);}    
    #hud{position:fixed;left:20px;top:20px;display:flex;gap:14px;align-items:center;background:rgba(18,21,28,0.85);padding:12px 16px;border-radius:16px;border:1px solid #1e293b;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);box-shadow:0 8px 25px rgba(0,0,0,0.4)}
    .btn{border:0;padding:10px 14px;border-radius:12px;background:linear-gradient(135deg,#1e293b,#0f172a);color:#c4d1e0;cursor:pointer;border:1px solid #334155;transition:all 0.2s}
    .btn:hover{background:linear-gradient(135deg,#334155,#1e293b)}
    .btn.on{background:linear-gradient(135deg,#1e40af,#1d4ed8);box-shadow:0 0 0 1px #3b82f6 inset;color:#fff}
    .range{accent-color:#3b82f6}
    #panel{position:fixed;right:20px;top:20px;width:300px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5)}
    #panel h4{margin:0 0 8px;font-weight:600;color:#f1f5f9;font-size:15px}
    #trace{width:100%;height:150px;background:#0f172a;border-radius:12px;border:1px solid #1e293b}
    #err{position:fixed;left:20px;bottom:20px;background:#dc2626;color:#fff;padding:10px 14px;border-radius:12px;display:none}
    #controls{position:fixed;left:20px;bottom:20px;width:300px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);max-height:300px;overflow-y:auto}
    .control-group{margin-bottom:12px}
    .control-group label{display:block;margin-bottom:4px;font-size:13px;color:#94a3b8}
    .control-group input[type="range"]{width:100%;accent-color:#3b82f6}
    .toggle{background:#1e293b;border:1px solid #334155;padding:6px 12px;border-radius:8px;cursor:pointer;display:inline-block;margin:2px}
    .toggle.active{background:#1e40af;color:#fff}
    #info{position:fixed;right:20px;bottom:20px;width:320px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);font-size:13px;line-height:1.6}
    .lesson{background:#0f172a;padding:12px;border-radius:8px;margin:8px 0;border-left:3px solid #3b82f6}
  </style>
</head>
<body>
<div id="overlay"></div>
<div id="hud">
  <div style="font-weight:600;color:#f1f5f9">SNN • Neural Network</div>
  <button id="play" class="btn on">Pause</button>
  <label style="color:#94a3b8">Speed <input id="speed" class="range" type="range" min="10" max="150" value="50"/></label>
</div>

<div id="panel">
  <h4 id="sel">Select Neuron</h4>
  <div style="margin-bottom:8px;font-size:12px;color:#94a3b8">
    Voltage: <span id="voltageValue" style="color:#f223e0;font-weight:bold">--</span>
    <span style="margin-left:10px">Threshold: <span style="color:#60a5fa">1.0</span></span>
  </div>
  <canvas id="trace" width="260" height="150"></canvas>
</div>

<div id="controls">
  <h4 style="margin:0 0 12px;color:#f1f5f9">Learning Controls</h4>
  <div class="control-group">
    <label for="inputCurrent">Input Current: <span id="inputValue">0.5</span></label>
    <input type="range" id="inputCurrent" min="0" max="2" step="0.1" value="0.5"/>
  </div>
  <button id="resetNetwork" class="btn">Reset Network</button>
  <button id="showWeights" class="btn">Show Weights</button>
</div>

<div id="info">
  <h4 style="margin:0 0 8px;color:#f1f5f9">Learning Guide</h4>
  <div id="lessonContent">
    <div class="lesson">
      <strong>Lesson 1: Basic Spikes</strong><br>
      Each neuron accumulates voltage over time. When it reaches threshold (v=1), it fires a spike and resets to 0.
    </div>
  </div>
</div>
<div id="err"></div>

<script src="three.min.js"></script>
<script>
(function(){
  const showErr = m => {
    const e = document.getElementById('err');
    e.textContent = m;
    e.style.display = 'block';
  };
  
  if (!window.THREE) {
    showErr('Three.js missing. Please download three.min.js');
    return;
  }

  // WebSocket connection
  let ws;
  function connectWS() {
    try {
      ws = new WebSocket('ws://localhost:8766');
      ws.onopen = () => {
        console.log('Connected to SNN server');
        document.getElementById('err').style.display = 'none';
      };
      ws.onerror = () => showErr('Connection failed. Make sure server.py is running.');
      ws.onclose = () => setTimeout(connectWS, 2000);
      ws.onmessage = handleMessage;
    } catch (error) {
      showErr('Failed to connect to server');
    }
  }

  // Constants
  const NUM = 50;
  const CLUSTER_COLORS = [
    { primary: new THREE.Color(0.0, 0.8, 1.0), glow: new THREE.Color(0.3, 0.9, 1.0) },
    { primary: new THREE.Color(1.0, 0.2, 0.8), glow: new THREE.Color(1.0, 0.5, 0.9) },
    { primary: new THREE.Color(0.9, 1.0, 0.0), glow: new THREE.Color(1.0, 1.0, 0.4) },
    { primary: new THREE.Color(1.0, 0.5, 0.0), glow: new THREE.Color(1.0, 0.7, 0.3) },
    { primary: new THREE.Color(1.0, 0.0, 0.4), glow: new THREE.Color(1.0, 0.3, 0.6) }
  ];

  // Three.js setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 0, 120);
  
  const renderer = new THREE.WebGLRenderer({antialias: true, powerPreference: "high-performance"});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  scene.add(new THREE.AmbientLight(0x0a0a0a, 0.3));
  const keyLight = new THREE.PointLight(0x4080ff, 2.0, 200);
  keyLight.position.set(80, 80, 80);
  scene.add(keyLight);

  // Global variables
  const neurons = [], glows = [], connectionLabels = [];
  let connections = [];
  let connGeom, col, lines;
  let selected = null, traceBuf = [];
  let showWeights = false;

  // Create network topology
  function createNetworkTopology() {
    // Clear existing
    neurons.forEach(n => scene.remove(n));
    glows.forEach(g => scene.remove(g));
    neurons.length = 0;
    glows.length = 0;

    const radius = 35;
    const N_EXC = 40, N_INH = 10;
    
    // Create excitatory neurons
    for (let i = 0; i < N_EXC; i++) {
      const clusterId = Math.floor(i / (N_EXC / 4));
      const clusterColor = CLUSTER_COLORS[clusterId];
      
      const angleY = (i / (N_EXC / 4)) * Math.PI * 2 + clusterId * Math.PI * 0.5;
      const angleX = (Math.floor(i / (N_EXC / 3)) / 3) * Math.PI;
      const clusterRadius = radius + (Math.random() - 0.5) * 15;
      
      const position = new THREE.Vector3(
        Math.sin(angleX) * Math.cos(angleY) * clusterRadius,
        Math.cos(angleX) * clusterRadius * 0.7,
        Math.sin(angleX) * Math.sin(angleY) * clusterRadius
      );

      const geometry = new THREE.SphereGeometry(1.2, 24, 24);
      const material = new THREE.MeshStandardMaterial({
        color: clusterColor.primary,
        emissive: clusterColor.primary.clone().multiplyScalar(0.4),
        roughness: 0.3,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });

      const neuron = new THREE.Mesh(geometry, material);
      neuron.position.copy(position);
      neuron.userData = {
        id: i,
        cluster: clusterId,
        pulse: 0,
        volt: 0,
        type: 'excitatory',
        originalColor: clusterColor.primary.clone(),
        glowColor: clusterColor.glow.clone()
      };
      scene.add(neuron);
      neurons.push(neuron);

      // Glow effect
      const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: clusterColor.glow,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(position);
      scene.add(glow);
      glows.push(glow);
    }

    // Create inhibitory neurons
    for (let i = 0; i < N_INH; i++) {
      const angle = (i / N_INH) * Math.PI * 2;
      const height = (Math.random() - 0.5) * 40;
      const r = radius * 1.3;
      
      const position = new THREE.Vector3(Math.cos(angle) * r, height, Math.sin(angle) * r);

      const geometry = new THREE.SphereGeometry(1.0, 20, 20);
      const material = new THREE.MeshStandardMaterial({
        color: CLUSTER_COLORS[4].primary,
        emissive: CLUSTER_COLORS[4].primary.clone().multiplyScalar(0.4),
        roughness: 0.3,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });

      const neuron = new THREE.Mesh(geometry, material);
      neuron.position.copy(position);
      neuron.userData = {
        id: i + N_EXC,
        cluster: 4,
        pulse: 0,
        volt: 0,
        type: 'inhibitory',
        originalColor: CLUSTER_COLORS[4].primary.clone(),
        glowColor: CLUSTER_COLORS[4].glow.clone()
      };
      scene.add(neuron);
      neurons.push(neuron);

      const glowGeometry = new THREE.SphereGeometry(2.0, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: CLUSTER_COLORS[4].glow,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(position);
      scene.add(glow);
      glows.push(glow);
    }

    createConnectionNetwork();
    console.log(`Created network: ${neurons.length} neurons`);
  }

  function createConnectionNetwork() {
    const positions = [];
    const colors = [];
    const connectionData = [];
    
    for (let i = 0; i < neurons.length; i++) {
      for (let j = 0; j < neurons.length; j++) {
        if (i !== j) {
          const prob = neurons[i].userData.cluster === neurons[j].userData.cluster ? 0.6 : 0.3;
          
          if (Math.random() < prob) {
            const fromPos = neurons[i].position;
            const toPos = neurons[j].position;
            
            positions.push(fromPos.x, fromPos.y, fromPos.z);
            positions.push(toPos.x, toPos.y, toPos.z);
            
            const fromCluster = neurons[i].userData.cluster;
            const color = CLUSTER_COLORS[fromCluster].primary.clone().multiplyScalar(0.4);
            
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
            
            connectionData.push({ from: i, to: j, cluster: fromCluster });
          }
        }
      }
    }
    
    connGeom = new THREE.BufferGeometry();
    connGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    connGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    col = connGeom.getAttribute('color');
    
    const lineMat = new THREE.LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    
    lines = new THREE.LineSegments(connGeom, lineMat);
    scene.add(lines);
    
    connections = connectionData;
    console.log(`Created ${connections.length} connections`);
  }

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    const clusterActivity = [0, 0, 0, 0, 0];
    
    for (let i = 0; i < neurons.length; i++) {
      const n = neurons[i], g = glows[i], u = n.userData;
      
      // Always visible base color with voltage modulation
      const voltage = Math.max(0, Math.min(1, u.volt || 0));
      const baseColor = u.originalColor.clone();
      baseColor.lerp(u.glowColor, voltage * 0.4);
      n.material.color.copy(baseColor);
      
      if (u.pulse > 0) {
        u.pulse *= 0.85;
        const intensity = u.pulse / 1.2;
        
        clusterActivity[u.cluster] += intensity;
        
        // Bright firing effects
        const glowColor = u.glowColor.clone().multiplyScalar(intensity * 2);
        n.material.emissive.copy(glowColor);
        n.scale.setScalar(1.0 + intensity * 0.4);
        
        // Enhanced glow
        g.material.opacity = 0.2 + intensity * 0.6;
        g.scale.setScalar(1.0 + intensity * 3.0);
        g.material.color.copy(u.glowColor);
        
      } else {
        // Base state - always visible
        n.material.emissive.copy(u.originalColor.clone().multiplyScalar(0.4));
        n.scale.setScalar(1.0);
        g.material.opacity = 0.15;
        g.scale.setScalar(1.0);
      }
    }
    
    // Update connection colors based on cluster activity
    if (connGeom && col && connections.length > 0) {
      for (let i = 0; i < connections.length; i++) {
        const conn = connections[i];
        const baseIdx = i * 6;
        
        if (baseIdx + 5 < col.array.length) {
          const clusterColor = CLUSTER_COLORS[conn.cluster].primary;
          const activity = clusterActivity[conn.cluster];
          
          // Always visible base + activity boost
          const baseIntensity = 0.4;
          const activityBoost = Math.min(activity * 0.8, 1.0);
          const totalIntensity = baseIntensity + activityBoost;
          
          col.array[baseIdx] = clusterColor.r * totalIntensity;
          col.array[baseIdx + 1] = clusterColor.g * totalIntensity;
          col.array[baseIdx + 2] = clusterColor.b * totalIntensity;
          col.array[baseIdx + 3] = clusterColor.r * totalIntensity;
          col.array[baseIdx + 4] = clusterColor.g * totalIntensity;
          col.array[baseIdx + 5] = clusterColor.b * totalIntensity;
        }
      }
      col.needsUpdate = true;
    }
    
    drawTrace();
    renderer.render(scene, camera);
  }

  // Message handling
  function handleMessage(e) {
    const d = JSON.parse(e.data);
    
    if (d.volt) {
      for (const k in d.volt) {
        const i = +k;
        if (neurons[i]) {
          neurons[i].userData.volt = d.volt[k];
          if (selected === i) {
            traceBuf.push(d.volt[k]);
            if (traceBuf.length > 200) traceBuf.shift();
          }
        }
      }
    }
    
    if (d.spikes) {
      d.spikes.forEach(i => {
        if (neurons[i]) {
          neurons[i].userData.pulse = 1.2;
        }
      });
    }
  }

  // UI Controls
  const btn = document.getElementById('play');
  const rng = document.getElementById('speed');
  let isPlaying = true;

  btn.onclick = () => {
    isPlaying = !isPlaying;
    btn.textContent = isPlaying ? 'Pause' : 'Play';
    btn.classList.toggle('on', isPlaying);
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ cmd: isPlaying ? 'play' : 'pause' }));
    }
  };

  rng.oninput = () => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ cmd: 'speed', value: parseInt(rng.value, 10) }));
    }
  };

  const resetBtn = document.getElementById('resetNetwork');
  resetBtn.onclick = () => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ cmd: 'reset' }));
    }
  };

  const showWeightsBtn = document.getElementById('showWeights');
  showWeightsBtn.onclick = () => {
    showWeights = !showWeights;
    showWeightsBtn.textContent = showWeights ? 'Hide Weights' : 'Show Weights';
    showWeightsBtn.classList.toggle('on', showWeights);
    // Logic to show/hide weights would go here, possibly via WebSocket
  };

  const inputCurrent = document.getElementById('inputCurrent');
  const inputValue = document.getElementById('inputValue');
  inputCurrent.oninput = () => {
    inputValue.textContent = inputCurrent.value;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ cmd: 'setInput', value: parseFloat(inputCurrent.value) }));
    }
  };

  // Drawing and interaction
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function onMouseClick(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(neurons);

    if (intersects.length > 0) {
      const newSelected = intersects[0].object.userData.id;
      if (selected !== null && neurons[selected]) {
        neurons[selected].scale.setScalar(1.0); // Deselect old
      }
      selected = newSelected;
      neurons[selected].scale.setScalar(1.5); // Select new
      document.getElementById('sel').textContent = `Neuron ${selected}`;
      traceBuf = [];
    }
  }
  window.addEventListener('click', onMouseClick);

  function drawTrace() {
    const c = document.getElementById('trace').getContext('2d');
    c.fillStyle = '#0f172a';
    c.fillRect(0, 0, 260, 150);
    
    if (selected === null || !neurons[selected]) {
      document.getElementById('voltageValue').textContent = '--';
      return;
    }
    
    document.getElementById('voltageValue').textContent = neurons[selected].userData.volt.toFixed(3);

    c.strokeStyle = '#60a5fa';
    c.lineWidth = 1;
    c.setLineDash([5, 5]);
    c.beginPath();
    c.moveTo(0, 150 - 1.0 * 130);
    c.lineTo(260, 150 - 1.0 * 130);
    c.stroke();
    c.setLineDash([]);

    if (traceBuf.length > 1) {
      c.strokeStyle = '#f223e0';
      c.lineWidth = 2;
      c.beginPath();
      for (let i = 0; i < traceBuf.length; i++) {
        const x = i / (traceBuf.length - 1) * 260;
        const y = 150 - Math.min(traceBuf[i], 2.0) * 65;
        i === 0 ? c.moveTo(x, y) : c.lineTo(x, y);
      }
      c.stroke();
    }
  }

  // Initialize
  createNetworkTopology();
  connectWS();
  animate();

  // Handle window resize
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

})();
</script>
</body>
</html>
