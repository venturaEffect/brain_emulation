<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SNN Visualizer — SYNTHETIC-2</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--bg:#0a0c12;--panel:#12151c;--text:#c4d1e0;--muted:#6b7280;--edge:#1e293b;--edgeHot:#3b82f6;--node:#60a5fa;--hot:#f59e0b;--pulse:#ef4444}
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.5 Inter,system-ui,Helvetica,Arial;overflow:hidden}
    canvas{display:block}
    #overlay{pointer-events:none;position:fixed;inset:0;background:
      radial-gradient(1400px 900px at 30% 0%, #1e293b22, transparent 70%),
      radial-gradient(1000px 600px at 80% 100%, #1e1b4b22, transparent 60%);}    
    #hud{position:fixed;left:20px;top:20px;display:flex;gap:14px;align-items:center;background:rgba(18,21,28,0.85);padding:12px 16px;border-radius:16px;border:1px solid #1e293b;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);box-shadow:0 8px 25px rgba(0,0,0,0.4)}
    .btn{border:0;padding:10px 14px;border-radius:12px;background:linear-gradient(135deg,#1e293b,#0f172a);color:#c4d1e0;cursor:pointer;border:1px solid #334155;transition:all 0.2s}
    .btn:hover{background:linear-gradient(135deg,#334155,#1e293b)}
    .btn.on{background:linear-gradient(135deg,#1e40af,#1d4ed8);box-shadow:0 0 0 1px #3b82f6 inset;color:#fff}
    .range{accent-color:#3b82f6}
    #panel{position:fixed;right:20px;top:20px;width:300px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5)}
    #panel h4{margin:0 0 8px;font-weight:600;color:#f1f5f9;font-size:15px}
    #trace{width:100%;height:150px;background:#0f172a;border-radius:12px;border:1px solid #1e293b}
    #err{position:fixed;left:20px;bottom:20px;background:#dc2626;color:#fff;padding:10px 14px;border-radius:12px;display:none}
    .hint{position:fixed;left:20px;bottom:20px;color:var(--muted)}
    #controls{position:fixed;left:20px;bottom:20px;width:300px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);max-height:300px;overflow-y:auto}
    .control-group{margin-bottom:12px}
    .control-group label{display:block;margin-bottom:4px;font-size:13px;color:#94a3b8}
    .control-group input[type="range"]{width:100%;accent-color:#3b82f6}
    .control-group input[type="number"]{width:80px;padding:4px 8px;background:#0f172a;border:1px solid #1e293b;border-radius:6px;color:#c4d1e0}
    .toggle{background:#1e293b;border:1px solid #334155;padding:6px 12px;border-radius:8px;cursor:pointer;display:inline-block;margin:2px}
    .toggle.active{background:#1e40af;color:#fff}
    #info{position:fixed;right:20px;bottom:20px;width:320px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);font-size:13px;line-height:1.6}
    .lesson{background:#0f172a;padding:12px;border-radius:8px;margin:8px 0;border-left:3px solid #3b82f6}
    #lessonSelect{padding:6px 12px;background:#0f172a;border:1px solid #334155;color:#cbd5e1;border-radius:6px;min-width:200px;font-family:Inter,system-ui}
  </style>
</head>
<body>
<div id="overlay"></div>
<div id="hud">
  <div style="font-weight:600;color:#f1f5f9">SNN • Neural Network</div>
  <button id="play" class="btn on">Pause</button>
  <label style="color:#94a3b8">Speed <input id="speed" class="range" type="range" min="10" max="150" value="50"/></label>
</div>

<!-- NEW LESSON DROPDOWN PANEL -->
<div id="lessonPanel" style="position:fixed;left:20px;top:80px;display:flex;gap:12px;align-items:center;background:rgba(18,21,28,0.85);padding:10px 16px;border-radius:12px;border:1px solid #1e293b;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);box-shadow:0 8px 25px rgba(0,0,0,0.4)">
  <label for="lessonSelect" style="color:#94a3b8;font-weight:500;">Lesson:</label>
  <select id="lessonSelect">
    <option value="1">Lesson 1: Basic Spike Dynamics</option>
    <option value="2">Lesson 2: Synaptic Transmission</option>
    <option value="3">Lesson 3: Network Plasticity</option>
    <option value="4">Lesson 4: Pattern Recognition</option>
  </select>
  <div style="display:flex;gap:8px;">
    <button id="prevLesson" class="btn" style="padding:6px 10px;font-size:12px;">← Prev</button>
    <button id="nextLesson" class="btn" style="padding:6px 10px;font-size:12px;">Next →</button>
    <button id="viewLesson" class="btn" style="padding:6px 10px;font-size:12px;background:#f223e0;color:#fff;">📖 View Full</button>
  </div>
</div>

<div id="panel">
  <h4 id="sel">Select Neuron</h4>
  <div style="margin-bottom:8px;font-size:12px;color:#94a3b8">
    Voltage: <span id="voltageValue" style="color:#f223e0;font-weight:bold">--</span>
    <span style="margin-left:10px">Threshold: <span style="color:#60a5fa">1.0</span></span>
  </div>
  <canvas id="trace" width="260" height="150"></canvas>
</div>
<div id="controls">
  <h4 style="margin:0 0 12px;color:#f1f5f9">Learning Controls</h4>
  
  <div class="control-group">
    <label>Lesson Mode:</label>
    <div class="toggle active" id="lesson1">Basic Spikes</div>
    <div class="toggle" id="lesson2">Synapses</div>
    <div class="toggle" id="lesson3">Plasticity</div>
    <div class="toggle" id="lesson4">Patterns</div>
  </div>
  
  <div class="control-group">
    <label for="inputCurrent">Input Current: <span id="inputValue">0.5</span></label>
    <input type="range" id="inputCurrent" min="0" max="2" step="0.1" value="0.5"/>
  </div>
  
  <div class="control-group">
    <label for="synapseWeight">Synaptic Weight: <span id="weightValue">0.2</span></label>
    <input type="range" id="synapseWeight" min="0" max="1" step="0.05" value="0.2"/>
  </div>
  
  <div class="control-group">
    <label for="networkSize">Network Size: <span id="sizeValue">50</span></label>
    <input type="range" id="networkSize" min="10" max="100" step="5" value="50"/>
  </div>
  
  <div class="control-group">
    <label for="connectionProb">Connection Probability: <span id="probValue">0.045</span></label>
    <input type="range" id="connectionProb" min="0" max="0.2" step="0.005" value="0.045"/>
  </div>
  
  <button id="resetNetwork" class="btn">Reset Network</button>
  <button id="showWeights" class="btn">Show Weights</button>
  
  <!-- Lesson 4 specific controls (hidden by default) -->
  <div class="control-group" id="patternControls" style="display:none;">
    <button id="injectPattern" class="btn" style="width:100%;margin-bottom:8px;">Inject Pattern</button>
    <button id="testMemory" class="btn" style="width:100%;">Test Memory</button>
  </div>
</div>

<div id="info">
  <h4 style="margin:0 0 8px;color:#f1f5f9">Learning Guide</h4>
  <div id="lessonContent">
    <div class="lesson">
      <strong>Lesson 1: Basic Spikes</strong><br>
      Each neuron accumulates voltage over time. When it reaches threshold (v=1), it fires a spike and resets to 0.
      <br><br>
      <strong>Try:</strong> Adjust input current and watch firing rates change.
    </div>
  </div>
</div>
<div id="err"></div>

<!-- FULL LESSON MODAL -->
<div id="lessonModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:1000;overflow-y:auto;">
  <div style="max-width:800px;margin:40px auto;background:#12151c;border:1px solid #334155;border-radius:16px;padding:24px;position:relative;">
    <button id="closeModal" style="position:absolute;top:16px;right:16px;background:none;border:none;color:#94a3b8;font-size:24px;cursor:pointer;">×</button>
    <div id="lessonFullContent" style="color:#cbd5e1;line-height:1.6;">
      <!-- Full lesson content will be loaded here -->
    </div>
  </div>
</div>

<script src="three.min.js"></script>
<script>
(function(){
  const showErr=m=>{const e=document.getElementById('err');e.textContent=m;e.style.display='block'};
  
  // Check if Three.js is loaded properly
  if(!window.THREE){
    showErr('Three.js missing. Please download three.min.js from https://threejs.org/build/three.min.js');
    return;
  }

  console.log('Three.js loaded successfully:', THREE.REVISION);

  // WebSocket connection
  let ws;
  function connectWS() {
    try {
      ws = new WebSocket(`ws://localhost:8766`);
      
      ws.onopen = () => {
        console.log('Connected to SNN server');
        document.getElementById('err').style.display = 'none';
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        showErr('Connection failed. Make sure server.py is running.');
      };
      
      ws.onclose = () => {
        console.log('WebSocket connection closed');
        setTimeout(connectWS, 2000);
      };
      
      ws.onmessage = handleMessage;
      
    } catch (error) {
      console.error('Failed to create WebSocket:', error);
      showErr('Failed to connect to server');
    }
  }

  const NUM=50, N_EXC = 40, N_INH = 10;
  
  // STUNNING CLUSTER COLORS - inspired by premium neural network visualizations
  const CLUSTER_COLORS = [
    { primary: new THREE.Color(0.2, 0.8, 1.0), glow: new THREE.Color(0.4, 0.9, 1.0), name: "Sensory" },     // Cyan
    { primary: new THREE.Color(1.0, 0.4, 0.8), glow: new THREE.Color(1.0, 0.6, 0.9), name: "Motor" },       // Magenta
    { primary: new THREE.Color(0.8, 1.0, 0.2), glow: new THREE.Color(0.9, 1.0, 0.4), name: "Memory" },      // Lime
    { primary: new THREE.Color(1.0, 0.8, 0.2), glow: new THREE.Color(1.0, 0.9, 0.4), name: "Control" },     // Orange
    { primary: new THREE.Color(1.0, 0.2, 0.2), glow: new THREE.Color(1.0, 0.4, 0.4), name: "Inhibitory" }   // Red
  ];

  // Initialize Three.js with PREMIUM QUALITY
  console.log('Initializing PREMIUM Three.js scene...');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);  // Pure black background
  scene.fog = new THREE.Fog(0x000000, 100, 300);  // Atmospheric depth
  
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 0, 120);
  
  const renderer = new THREE.WebGLRenderer({antialias: true, alpha: false, powerPreference: "high-performance"});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  document.body.appendChild(renderer.domElement);

  // CINEMATIC LIGHTING SETUP
  scene.add(new THREE.AmbientLight(0x0a0a0a, 0.3));  // Very dim ambient

  // Main key light
  const keyLight = new THREE.PointLight(0x4080ff, 2.0, 200);
  keyLight.position.set(80, 80, 80);
  keyLight.castShadow = true;
  keyLight.shadow.mapSize.width = 2048;
  keyLight.shadow.mapSize.height = 2048;
  scene.add(keyLight);

  // Accent lights for different clusters
  const accentLights = [];
  CLUSTER_COLORS.forEach((cluster, i) => {
    const angle = (i / CLUSTER_COLORS.length) * Math.PI * 2;
    const light = new THREE.PointLight(cluster.primary.getHex(), 0.8, 150);
    light.position.set(
      Math.cos(angle) * 100,
      Math.sin(angle) * 100,
      Math.sin(angle * 2) * 50
    );
    scene.add(light);
    accentLights.push(light);
  });

  // PARTICLE SYSTEM for connection flows
  class ConnectionFlow {
    constructor() {
      this.particles = [];
      this.geometry = new THREE.BufferGeometry();
      this.material = new THREE.PointsMaterial({
        size: 2,
        transparent: true,
        opacity: 0.8,
        vertexColors: true,
        blending: THREE.AdditiveBlending
      });
      this.points = new THREE.Points(this.geometry, this.material);
      scene.add(this.points);
    }

    addFlow(fromPos, toPos, color, speed = 0.02) {
      for (let i = 0; i < 5; i++) {
        this.particles.push({
          start: fromPos.clone(),
          end: toPos.clone(),
          current: fromPos.clone(),
          color: color,
          progress: i * 0.2,
          speed: speed + Math.random() * 0.01,
          life: 1.0
        });
      }
    }

    update() {
      const positions = [];
      const colors = [];

      this.particles = this.particles.filter(particle => {
        particle.progress += particle.speed;
        particle.life -= 0.01;

        if (particle.progress >= 1.0 || particle.life <= 0) return false;

        // Smooth interpolation along connection
        particle.current.lerpVectors(particle.start, particle.end, 
          THREE.MathUtils.smoothstep(particle.progress, 0, 1));

        positions.push(particle.current.x, particle.current.y, particle.current.z);
        colors.push(particle.color.r, particle.color.g, particle.color.b);

        return true;
      });

      this.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      this.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    }
  }

  const connectionFlow = new ConnectionFlow();

  // PREMIUM NEURAL NETWORK TOPOLOGY
  const neurons = [], glows = [], connectionLabels = [];
  let connections = [];

  function createStunningNetworkTopology() {
    // Clear existing
    neurons.forEach(n => scene.remove(n));
    glows.forEach(g => scene.remove(g));
    neurons.length = 0;
    glows.length = 0;

    // Create 4 distinct clusters in 3D space
    const clusterCenters = [
      new THREE.Vector3(-40, 30, 20),   // Sensory cluster
      new THREE.Vector3(40, 30, -20),   // Motor cluster  
      new THREE.Vector3(-40, -30, -20), // Memory cluster
      new THREE.Vector3(40, -30, 20),   // Control cluster
    ];

    // Create excitatory neurons in clusters
    for (let i = 0; i < N_EXC; i++) {
      const clusterId = Math.floor(i / (N_EXC / 4));
      const clusterCenter = clusterCenters[clusterId];
      const clusterColor = CLUSTER_COLORS[clusterId];
      
      // Position within cluster with some randomness
      const angle = (i % (N_EXC / 4)) / (N_EXC / 4) * Math.PI * 2;
      const radius = 8 + Math.random() * 6;
      const height = (Math.random() - 0.5) * 8;
      
      const position = new THREE.Vector3(
        clusterCenter.x + Math.cos(angle) * radius + (Math.random() - 0.5) * 4,
        clusterCenter.y + Math.sin(angle) * radius + (Math.random() - 0.5) * 4,
        clusterCenter.z + height
      );

      // High-quality neuron geometry
      const geometry = new THREE.SphereGeometry(1.8, 32, 32);
      const material = new THREE.MeshPhysicalMaterial({
        color: clusterColor.primary,
        emissive: new THREE.Color(0x000000),
        roughness: 0.1,
        metalness: 0.9,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        transparent: true,
        opacity: 0.9
      });

      const neuron = new THREE.Mesh(geometry, material);
      neuron.position.copy(position);
      neuron.userData = {
        id: i,
        cluster: clusterId,
        pulse: 0,
        volt: 0,
        type: 'excitatory',
        originalColor: clusterColor.primary.clone(),
        glowColor: clusterColor.glow.clone()
      };
      neuron.castShadow = true;
      neuron.receiveShadow = true;
      scene.add(neuron);
      neurons.push(neuron);

      // Stunning glow effect
      const glowGeometry = new THREE.SphereGeometry(3.5, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: clusterColor.glow,
        transparent: true,
        opacity: 0.0,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(position);
      scene.add(glow);
      glows.push(glow);
    }

    // Create inhibitory neurons (distributed around the network)
    for (let i = 0; i < N_INH; i++) {
      const angle = (i / N_INH) * Math.PI * 2;
      const radius = 60;
      const height = (Math.random() - 0.5) * 20;
      
      const position = new THREE.Vector3(
        Math.cos(angle) * radius,
        Math.sin(angle) * radius,
        height
      );

      const geometry = new THREE.OctahedronGeometry(1.5, 2);  // Different shape for inhibitory
      const material = new THREE.MeshPhysicalMaterial({
        color: CLUSTER_COLORS[4].primary,
        emissive: new THREE.Color(0x000000),
        roughness: 0.2,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });

      const neuron = new THREE.Mesh(geometry, material);
      neuron.position.copy(position);
      neuron.userData = {
        id: i + N_EXC,
        cluster: 4,
        pulse: 0,
        volt: 0,
        type: 'inhibitory',
        originalColor: CLUSTER_COLORS[4].primary.clone(),
        glowColor: CLUSTER_COLORS[4].glow.clone()
      };
      neuron.castShadow = true;
      neuron.receiveShadow = true;
      scene.add(neuron);
      neurons.push(neuron);

      // Red glow for inhibitory
      const glowGeometry = new THREE.SphereGeometry(3.0, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: CLUSTER_COLORS[4].glow,
        transparent: true,
        opacity: 0.0,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(position);
      scene.add(glow);
      glows.push(glow);
    }

    console.log(`Created stunning network: ${N_EXC} excitatory + ${N_INH} inhibitory neurons`);
  }

  createStunningNetworkTopology();

  // DYNAMIC CONNECTION VISUALIZATION
  function updateConnectionVisualization(connectionsData) {
    // Clear existing connection labels
    connectionLabels.forEach(label => {
      if (label.parent) label.parent.remove(label);
    });
    connectionLabels.length = 0;

    if (!showWeights || !connectionsData || connectionsData.length === 0) return;

    connections = connectionsData;

    // Create beautiful connection lines
    const connectionGeometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    
    connections.forEach(conn => {
      if (conn.from < neurons.length && conn.to < neurons.length) {
        const fromPos = neurons[conn.from].position;
        const toPos = neurons[conn.to].position;
        
        positions.push(fromPos.x, fromPos.y, fromPos.z);
        positions.push(toPos.x, toPos.y, toPos.z);
        
        // Color based on connection type and strength
        const color = conn.type === 'excitatory' ? 
          new THREE.Color(0.2, 0.8, 1.0) : 
          new THREE.Color(1.0, 0.2, 0.2);
        
        const intensity = Math.min(conn.weight * 3, 1.0);
        color.multiplyScalar(intensity);
        
        colors.push(color.r, color.g, color.b);
        colors.push(color.r, color.g, color.b);
      }
    });
    
    connectionGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    connectionGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    // Remove old lines
    scene.children = scene.children.filter(child => !(child instanceof THREE.LineSegments));
    
    // Add new connection lines
    const connectionMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });
    
    const connectionLines = new THREE.LineSegments(connectionGeometry, connectionMaterial);
    scene.add(connectionLines);

    console.log(`Visualized ${connections.length} stunning connections`);
  }

  // EPIC ANIMATION LOOP
  function animate() {
    requestAnimationFrame(animate);
    
    // Update neurons with STUNNING effects
    neurons.forEach((neuron, i) => {
      const userData = neuron.userData;
      const glow = glows[i];
      
      if (userData.pulse > 0) {
        userData.pulse *= 0.85;  // Smooth decay
        const intensity = userData.pulse / 1.2;
        
        // EPIC firing effect
        neuron.material.emissive.copy(userData.glowColor).multiplyScalar(intensity * 0.8);
        neuron.scale.setScalar(1.0 + intensity * 0.3);
        
        // Stunning glow expansion
        glow.material.opacity = intensity * 0.7;
        glow.scale.setScalar(1.0 + intensity * 2.0);
        
        // Add particle flow to connected neurons
        if (intensity > 0.5) {
          connections.forEach(conn => {
            if (conn.from === userData.id && Math.random() < 0.3) {
              const targetNeuron = neurons[conn.to];
              if (targetNeuron) {
                connectionFlow.addFlow(
                  neuron.position,
                  targetNeuron.position,
                  userData.glowColor,
                  0.025
                );
              }
            }
          });
        }
      } else {
        // Reset to base state
        neuron.material.emissive.setRGB(0, 0, 0);
        neuron.scale.setScalar(1.0);
        glow.material.opacity = 0.0;
        glow.scale.setScalar(1.0);
      }
      
      // Voltage-based subtle color shift
      const voltage = Math.max(0, Math.min(1, userData.volt || 0));
      const baseColor = userData.originalColor.clone();
      baseColor.lerp(userData.glowColor, voltage * 0.3);
      neuron.material.color.copy(baseColor);
      
      // Subtle breathing effect based on voltage
      neuron.material.opacity = 0.85 + voltage * 0.15;
    });
    
    // Update flowing particles
    connectionFlow.update();
    
    // Dynamic camera movement
    const time = Date.now() * 0.0005;
    camera.position.x = Math.cos(time * 0.3) * 5;
    camera.position.y = Math.sin(time * 0.2) * 3;
    camera.lookAt(0, 0, 0);
    
    // Dynamic accent lighting
    accentLights.forEach((light, i) => {
      const angle = time + i * Math.PI * 2 / accentLights.length;
      light.intensity = 0.5 + Math.sin(angle) * 0.3;
    });
    
    drawTrace();
    renderer.render(scene, camera);
  }

  // WebSocket message handler
  function handleMessage(e) {
    const d = JSON.parse(e.data);
    
    if (d.volt) {
      for (const k in d.volt) {
        const i = +k;
        if (neurons[i]) {
          const v = d.volt[k];
          neurons[i].userData.volt = v;
          if (selected === i) {
            traceBuf.push(v);
            if (traceBuf.length > 200) traceBuf.shift();
          }
        }
      }
    }
    
    if (d.spikes) {
      d.spikes.forEach(spike => {
        const i = spike.i;
        if (neurons[i]) {
          const neuron = neurons[i];
          neuron.userData.pulse = 1.2;
          
          // EPIC cluster synchronization effect
          const cluster = neuron.userData.cluster;
          
          // If multiple neurons in same cluster fire together, create cluster burst
          const clusterSpikes = d.spikes.filter(s => 
            neurons[s.i] && neurons[s.i].userData.cluster === cluster
          );
          
          if (clusterSpikes.length > 1) {
            // CLUSTER BURST EFFECT!
            neurons.forEach(n => {
              if (n.userData.cluster === cluster) {
                n.userData.pulse = Math.max(n.userData.pulse, 1.5);
              }
            });
            
            // Intensify cluster accent light
            if (accentLights[cluster]) {
              accentLights[cluster].intensity = 2.0;
            }
          }
        }
      });
    }
    
    if (d.cmd === "showConnections" && d.connections) {
      console.log(`Received ${d.connections.length} premium connections`);
      updateConnectionVisualization(d.connections);
    }
  }

  // Educational variables
  let showWeights = false;
  let currentLesson = 1;
  let connectionLabels = []; // Store connection weight labels

  // FIXED: Embedded lesson content
  const lessonContent = {
    1: {
      title: "Basic Spike Dynamics",
      content: `
        <h1>Lesson 1: Basic Spike Dynamics</h1>
        <h2>Learning Objectives</h2>
        <p>Understand how individual neurons integrate input current and generate action potentials (spikes) when reaching threshold voltage.</p>
        
        <h2>Theory</h2>
        <p><strong>Leaky Integrate-and-Fire Model:</strong></p>
        <p>Each neuron follows the equation: <code>dv/dt = (-v + I_input)/tau</code></p>
        <ul>
          <li><strong>v</strong>: membrane voltage</li>
          <li><strong>I_input</strong>: input current</li>
          <li><strong>tau</strong>: time constant (8ms)</li>
          <li><strong>Threshold</strong>: v = 1.0</li>
          <li><strong>Reset</strong>: v = 0 after spike</li>
        </ul>

        <h2>Interactive Experiments</h2>
        <h3>Experiment 1.1: Single Neuron Response</h3>
        <ol>
          <li><strong>Click on any blue neuron</strong> to select it</li>
          <li><strong>Observe the voltage trace</strong> in the right panel</li>
          <li><strong>Adjust Input Current</strong> using the slider (try 0.1 to 1.0)</li>
          <li><strong>Watch how voltage accumulates</strong> toward threshold</li>
        </ol>

        <h3>Key Observations</h3>
        <ul>
          <li><strong>Low current (< 0.5)</strong>: Voltage rises slowly, may not reach threshold</li>
          <li><strong>Medium current (0.5-1.0)</strong>: Regular spiking with predictable intervals</li>
          <li><strong>High current (> 1.0)</strong>: Rapid firing, short intervals between spikes</li>
        </ul>

        <h2>Questions to Explore</h2>
        <ol>
          <li>What is the minimum current needed for spiking?</li>
          <li>How does firing rate change with input current?</li>
          <li>What happens to voltage between spikes?</li>
        </ol>
      `
    },
    2: {
      title: "Synaptic Transmission",
      content: `
        <h1>Lesson 2: Synaptic Transmission</h1>
        <h2>Learning Objectives</h2>
        <p>Explore how neurons communicate through synaptic connections and how network interactions emerge.</p>
        
        <h2>Theory</h2>
        <p><strong>Synaptic Communication:</strong></p>
        <ul>
          <li>When a neuron spikes, it sends current to connected neurons</li>
          <li>Synaptic weight determines the strength of this influence</li>
          <li>Multiple inputs can sum to push neurons over threshold</li>
        </ul>

        <h2>Interactive Experiments</h2>
        <h3>Experiment 2.1: Network Propagation</h3>
        <ol>
          <li><strong>Set Input Current to 0.5</strong></li>
          <li><strong>Increase Synaptic Weight</strong> from 0.1 to 0.3</li>
          <li><strong>Click "Show Weights"</strong> to visualize connections</li>
          <li><strong>Watch</strong> how spikes spread through the network</li>
        </ol>

        <h3>Key Concepts</h3>
        <ul>
          <li><strong>Weak synapses</strong>: Isolated activity</li>
          <li><strong>Strong synapses</strong>: Cascading waves</li>
          <li><strong>Network amplification</strong>: Single inputs trigger multiple spikes</li>
        </ul>
      `
    },
    3: {
      title: "Network Plasticity", 
      content: `
        <h1>Lesson 3: Network Plasticity</h1>
        <h2>Learning Objectives</h2>
        <p>Understand how neural networks adapt and self-organize through activity-dependent changes.</p>
        
        <h2>Theory</h2>
        <p><strong>Critical Dynamics:</strong></p>
        <ul>
          <li><strong>Subcritical</strong>: Activity dies out quickly</li>
          <li><strong>Critical</strong>: Sustained, balanced activity</li>
          <li><strong>Supercritical</strong>: Explosive synchronization</li>
        </ul>

        <h2>Interactive Experiments</h2>
        <h3>Experiment 3.1: Phase Transitions</h3>
        <ol>
          <li><strong>Start with Connection Probability = 0.02</strong></li>
          <li><strong>Gradually increase to 0.15</strong></li>
          <li><strong>Observe</strong> the sudden change in network behavior</li>
          <li><strong>Find the critical point</strong> where dynamics shift</li>
        </ol>

        <h3>Real-World Applications</h3>
        <ul>
          <li><strong>Brain development</strong>: Networks self-organize during growth</li>
          <li><strong>Learning</strong>: Synaptic changes encode memories</li>
          <li><strong>Recovery</strong>: Networks reorganize after injury</li>
        </ul>
      `
    },
    4: {
      title: "Pattern Recognition",
      content: `
        <h1>Lesson 4: Pattern Recognition</h1>
        <h2>Learning Objectives</h2>
        <p>Explore how spiking networks can detect, learn, and recall temporal patterns.</p>
        
        <h2>Theory</h2>
        <p><strong>Neural Memory:</strong></p>
        <ul>
          <li><strong>Encoding</strong>: Patterns strengthen specific connections</li>
          <li><strong>Storage</strong>: Connection patterns persist over time</li>
          <li><strong>Recall</strong>: Partial inputs trigger full patterns</li>
        </ul>

        <h2>Interactive Experiments</h2>
        <h3>Experiment 4.1: Teaching Patterns</h3>
        <ol>
          <li><strong>Click "Inject Pattern"</strong> multiple times</li>
          <li><strong>Watch</strong> neurons [0, 5, 10, 15, 20] become active together</li>
          <li><strong>Observe</strong> how repeated patterns strengthen connections</li>
        </ol>

        <h3>Experiment 4.2: Memory Recall</h3>
        <ol>
          <li><strong>After teaching, click "Test Memory"</strong></li>
          <li><strong>Only neurons [0, 5] are stimulated</strong></li>
          <li><strong>Watch</strong> if the network completes the full pattern</li>
        </ol>

        <h3>Applications</h3>
        <ul>
          <li><strong>Biological memory</strong>: How brains store experiences</li>
          <li><strong>Artificial intelligence</strong>: Pattern recognition systems</li>
          <li><strong>Neuromorphic computing</strong>: Brain-inspired processors</li>
        </ul>
      `
    }
  };

  // FIXED: Add missing openLessonModal function
  function openLessonModal() {
    const modal = document.getElementById('lessonModal');
    const content = document.getElementById('lessonFullContent');
    
    if (!modal || !content) return;
    
    modal.style.display = 'block';
    
    const lesson = lessonContent[currentLesson];
    if (lesson) {
      content.innerHTML = lesson.content;
    } else {
      content.innerHTML = `
        <div style="text-align:center;padding:40px;color:#ef4444;">
          <h3>Lesson ${currentLesson} Content</h3>
          <p>Lesson content not available.</p>
        </div>
      `;
    }
  }

  // Educational controls setup
  function setupEducationalControls() {
    // Lesson dropdown functionality
    const lessonSelect = document.getElementById('lessonSelect');
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    const viewBtn = document.getElementById('viewLesson');
    
    if (lessonSelect) {
      lessonSelect.addEventListener('change', (e) => {
        currentLesson = parseInt(e.target.value);
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    }
    
    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        if (currentLesson > 1) {
          currentLesson--;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }
    
    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        if (currentLesson < 4) {
          currentLesson++;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }

    if (viewBtn) {
      viewBtn.addEventListener('click', () => {
        openLessonModal();
      });
    }

    // Modal controls
    const closeModal = document.getElementById('closeModal');
    const modal = document.getElementById('lessonModal');
    
    if (closeModal) {
      closeModal.addEventListener('click', () => {
        modal.style.display = 'none';
      });
    }

    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });
    }

    // Legacy lesson toggle buttons (keep for backwards compatibility)
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.toggle').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentLesson = parseInt(btn.id.replace('lesson', ''));
        lessonSelect.value = currentLesson;
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    });

    // Input controls
    const inputCurrent = document.getElementById('inputCurrent');
    const inputValue = document.getElementById('inputValue');
    if (inputCurrent && inputValue) {
      inputCurrent.addEventListener('input', () => {
        inputValue.textContent = inputCurrent.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setInput', value: parseFloat(inputCurrent.value)}));
        }
      });
    }

    const synapseWeight = document.getElementById('synapseWeight');
    const weightValue = document.getElementById('weightValue');
    if (synapseWeight && weightValue) {
      synapseWeight.addEventListener('input', () => {
        weightValue.textContent = synapseWeight.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setWeight', value: parseFloat(synapseWeight.value)}));
        }
      });
    }

    const connectionProb = document.getElementById('connectionProb');
    const probValue = document.getElementById('probValue');
    if (connectionProb && probValue) {
      connectionProb.addEventListener('input', () => {
        probValue.textContent = connectionProb.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setConnectionProb', value: parseFloat(connectionProb.value)}));
        }
      });
    }

    // Buttons
    const resetBtn = document.getElementById('resetNetwork');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'reset'}));
        }
      });
    }

    const showWeightsBtn = document.getElementById('showWeights');
    if (showWeightsBtn) {
      showWeightsBtn.addEventListener('click', () => {
        showWeights = !showWeights;
        showWeightsBtn.textContent = showWeights ? 'Hide Weights' : 'Show Weights';
        showWeightsBtn.classList.toggle('on', showWeights);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'toggleWeights'}));
        }
        
        // If hiding weights, clear labels immediately
        if (!showWeights) {
          connectionLabels.forEach(label => {
            if (label.parent) label.parent.remove(label);
          });
          connectionLabels = [];
          
          // Reset connection line colors to subtle
          if (connGeom && col) {
            const colors = connGeom.getAttribute('color');
            for(let i = 0; i < colors.array.length; i += 3) {
              colors.array[i] = 0.05;
              colors.array[i+1] = 0.08;
              colors.array[i+2] = 0.12;
            }
            colors.needsUpdate = true;
          }
        }
        
        console.log(`Weights visibility: ${showWeights}`);
      });
    }

    // Pattern controls for lesson 4
    const injectBtn = document.getElementById('injectPattern');
    const testBtn = document.getElementById('testMemory');
    
    if (injectBtn) {
      injectBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'injectPattern'}));
        }
      });
    }

    if (testBtn) {
      testBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'testMemory'}));
        }
      });
    }
  }

  function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    
    if (prevBtn) {
      prevBtn.disabled = currentLesson === 1;
      prevBtn.style.opacity = currentLesson === 1 ? '0.5' : '1';
    }
    
    if (nextBtn) {
      nextBtn.disabled = currentLesson === 4;
      nextBtn.style.opacity = currentLesson === 4 ? '0.5' : '1';
    }
  }

  function updateLessonControls() {
    // Show/hide controls based on current lesson
    const patternControls = document.getElementById('patternControls');
    const allControls = ['inputCurrent', 'synapseWeight', 'connectionProb', 'showWeights', 'resetNetwork'];
    
    // Show relevant controls for each lesson
    const lessonControlsMap = {
      1: ['inputCurrent', 'resetNetwork'],
      2: ['inputCurrent', 'synapseWeight', 'showWeights', 'resetNetwork'], 
      3: ['inputCurrent', 'synapseWeight', 'connectionProb', 'resetNetwork'],
      4: ['inputCurrent', 'synapseWeight', 'resetNetwork']
    };

    // Hide all controls first
    allControls.forEach(id => {
      const element = document.getElementById(id);
      if (element && element.closest('.control-group')) {
        element.closest('.control-group').style.display = 'none';
      }
    });

    // Show relevant controls
    lessonControlsMap[currentLesson].forEach(id => {
      const element = document.getElementById(id);
      if (element && element.closest('.control-group')) {
        element.closest('.control-group').style.display = 'block';
      }
    });

    // Show pattern controls only for lesson 4
    if (patternControls) {
      patternControls.style.display = currentLesson === 4 ? 'block' : 'none';
    }

    // Update toggle buttons
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.classList.remove('active');
    });
    const activeToggle = document.getElementById(`lesson${currentLesson}`);
    if (activeToggle) {
      activeToggle.classList.add('active');
    }
  }

  function updateLessonContent() {
    const lessons = {
      1: "Learn how individual neurons integrate input and generate spikes when reaching threshold. Click a neuron to see its voltage trace.",
      2: "Explore how neurons communicate through synaptic connections and network interactions. Adjust weights to see propagation effects.",
      3: "Understand how networks adapt and learn through activity-dependent changes. Experiment with connection density.",
      4: "Discover how spiking networks can detect and learn temporal patterns. Use pattern injection and memory testing."
    };
    
    const contentDiv = document.getElementById('lessonContent');
    if (contentDiv && lessons[currentLesson]) {
      contentDiv.innerHTML = `
        <div class="lesson">
          <strong>Lesson ${currentLesson}</strong><br>
          ${lessons[currentLesson]}
          <br><br>
          <button onclick="document.getElementById('viewLesson').click()" style="background:#f223e0;border:none;color:#fff;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;">
            📖 View Full Lesson
          </button>
        </div>
      `;
    }
  }

  const drawTrace=()=>{
    const c=document.getElementById('trace').getContext('2d'); 
    c.fillStyle='#0f172a'; 
    c.fillRect(0,0,260,150); 
    
    if(selected===null) {
      const voltageValue = document.getElementById('voltageValue');
      if (voltageValue) voltageValue.textContent = '--';
      return;
    }
    
    // Update voltage display
    const currentVoltage = neurons[selected].userData.volt || 0;
    const voltageValue = document.getElementById('voltageValue');
    if (voltageValue) {
      voltageValue.textContent = currentVoltage.toFixed(3);
    }
    
    // Draw threshold line
    c.strokeStyle='#60a5fa'; 
    c.lineWidth=1;
    c.setLineDash([5, 5]);
    const thresholdY = 148 - 1.0 * 130;
    c.beginPath();
    c.moveTo(2, thresholdY);
    c.lineTo(258, thresholdY);
    c.stroke();
    c.setLineDash([]);
    
    // Draw voltage trace
    if(traceBuf.length >= 2) {
      c.strokeStyle='#f223e0'; 
      c.lineWidth=2;
      c.beginPath(); 
      const L=traceBuf.length; 
      for(let i=0;i<L;i++){
        const x=i/(L-1)*256+2;
        const y=148-Math.max(0, Math.min(2, traceBuf[i]))*65;
        i?c.lineTo(x,y):c.moveTo(x,y);
      } 
      c.stroke();
    }
    
    // Add voltage scale labels
    c.fillStyle='#94a3b8';
    c.font='10px Inter';
    c.fillText('2.0V', 5, 15);
    c.fillText('1.0V', 5, 83);
    c.fillText('0.0V', 5, 145);
  };

  // WebSocket message handler
  function handleMessage(e) {
    const d=JSON.parse(e.data);
    if(d.volt){ 
      for(const k in d.volt){ 
        const i=+k; 
        if(neurons[i]){ 
          const v=d.volt[k]; 
          neurons[i].userData.volt=v; 
          if(selected===i){ 
            traceBuf.push(v); 
            if(traceBuf.length>200) traceBuf.shift();
          } 
        } 
      } 
    }
    if(d.spikes){ 
      d.spikes.forEach(s=>{
        const i=s.i; 
        if(!neurons[i]) return; 
        const n=neurons[i]; 
        n.userData.pulse=1.2; 
        
        (outgoing[i]||[]).forEach(seg=>{
          const a=seg*2*3, b=(seg*2+1)*3; 
          col.array[a]=col.array[b]=0.9; 
          col.array[a+1]=col.array[b+1]=0.95; 
          col.array[a+2]=col.array[b+2]=1.0;
        }); 
        col.needsUpdate=true;
      }); 
    }
    // FIXED: Handle connection visualization
    if(d.cmd === "showConnections" && d.connections) {
      console.log(`Received ${d.connections.length} connections`);
      updateConnectionVisualization(d.connections);
    }
  }

  // FIXED: Add connection visualization function
  function updateConnectionVisualization(connections) {
    // Clear existing visualization
    connectionLabels.forEach(label => {
      if (label.parent) label.parent.remove(label);
    });
    connectionLabels = [];

    if (!showWeights || connections.length === 0) return;

    // Create new connection geometry
    const positions = [];
    const colors = [];
    
    connections.forEach(conn => {
      if (conn.from < neurons.length && conn.to < neurons.length) {
        const fromPos = neurons[conn.from].position;
        const toPos = neurons[conn.to].position;
        
        positions.push(fromPos.x, fromPos.y, fromPos.z);
        positions.push(toPos.x, toPos.y, toPos.z);
        
        // Color based on connection type
        if (conn.type === 'excitatory') {
          colors.push(0.2, 0.6, 1.0, 0.2, 0.6, 1.0);  // Blue
        } else {
          colors.push(1.0, 0.3, 0.3, 1.0, 0.3, 0.3);  // Red for inhibitory
        }
        
        // Add weight label at midpoint
        const midPoint = new THREE.Vector3(
          (fromPos.x + toPos.x) / 2,
          (fromPos.y + toPos.y) / 2,
          (fromPos.z + toPos.z) / 2
        );

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 32;
        
        context.fillStyle = conn.type === 'excitatory' ? '#60a5fa' : '#ef4444';
        context.font = '10px Inter';
        context.textAlign = 'center';
        context.fillText(conn.weight.toFixed(3), 32, 20);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ 
          map: texture, 
          transparent: true,
          opacity: 0.7
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(midPoint);
        sprite.scale.set(3, 1.5, 1);
        
        scene.add(sprite);
        connectionLabels.push(sprite);
      }
    });
    
    // Update geometry
    connGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    connGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    console.log(`Visualized ${connections.length} realistic connections`);
  }

  // Educational controls setup
  function setupEducationalControls() {
    // Lesson dropdown functionality
    const lessonSelect = document.getElementById('lessonSelect');
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    const viewBtn = document.getElementById('viewLesson');
    
    if (lessonSelect) {
      lessonSelect.addEventListener('change', (e) => {
        currentLesson = parseInt(e.target.value);
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    }
    
    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        if (currentLesson > 1) {
          currentLesson--;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }
    
    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        if (currentLesson < 4) {
          currentLesson++;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }

    if (viewBtn) {
      viewBtn.addEventListener('click', () => {
        openLessonModal();
      });
    }

    // Modal controls
    const closeModal = document.getElementById('closeModal');
    const modal = document.getElementById('lessonModal');
    
    if (closeModal) {
      closeModal.addEventListener('click', () => {
        modal.style.display = 'none';
      });
    }

    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });
    }

    // Legacy lesson toggle buttons (keep for backwards compatibility)
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.toggle').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentLesson = parseInt(btn.id.replace('lesson', ''));
        lessonSelect.value = currentLesson;
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    });

    // Input controls
    const inputCurrent = document.getElementById('inputCurrent');
    const inputValue = document.getElementById('inputValue');
    if (inputCurrent && inputValue) {
      inputCurrent.addEventListener('input', () => {
        inputValue.textContent = inputCurrent.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setInput', value: parseFloat(inputCurrent.value)}));
        }
      });
    }

    const synapseWeight = document.getElementById('synapseWeight');
    const weightValue = document.getElementById('weightValue');
    if (synapseWeight && weightValue) {
      synapseWeight.addEventListener('input', () => {
        weightValue.textContent = synapseWeight.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setWeight', value: parseFloat(synapseWeight.value)}));
        }
      });
    }

    const connectionProb = document.getElementById('connectionProb');
    const probValue = document.getElementById('probValue');
    if (connectionProb && probValue) {
      connectionProb.addEventListener('input', () => {
        probValue.textContent = connectionProb.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setConnectionProb', value: parseFloat(connectionProb.value)}));
        }
      });
    }

    // Buttons
    const resetBtn = document.getElementById('resetNetwork');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'reset'}));
        }
      });
    }

    const showWeightsBtn = document.getElementById('showWeights');
    if (showWeightsBtn) {
      showWeightsBtn.addEventListener('click', () => {
        showWeights = !showWeights;
        showWeightsBtn.textContent = showWeights ? 'Hide Weights' : 'Show Weights';
        showWeightsBtn.classList.toggle('on', showWeights);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'toggleWeights'}));
        }
        
        // If hiding weights, clear labels immediately
        if (!showWeights) {
          connectionLabels.forEach(label => {
            if (label.parent) label.parent.remove(label);
          });
          connectionLabels = [];
          
          // Reset connection line colors to subtle
          if (connGeom && col) {
            const colors = connGeom.getAttribute('color');
            for(let i = 0; i < colors.array.length; i += 3) {
              colors.array[i] = 0.05;
              colors.array[i+1] = 0.08;
              colors.array[i+2] = 0.12;
            }
            colors.needsUpdate = true;
          }
        }
        
        console.log(`Weights visibility: ${showWeights}`);
      });
    }

    // Pattern controls for lesson 4
    const injectBtn = document.getElementById('injectPattern');
    const testBtn = document.getElementById('testMemory');
    
    if (injectBtn) {
      injectBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'injectPattern'}));
        }
      });
    }

    if (testBtn) {
      testBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'testMemory'}));
        }
      });
    }
  }

  function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    
    if (prevBtn) {
      prevBtn.disabled = currentLesson === 1;
      prevBtn.style.opacity = currentLesson === 1 ? '0.5' : '1';
    }
    
    if (nextBtn) {
      nextBtn.disabled = currentLesson === 4;
      nextBtn.style.opacity = currentLesson === 4 ? '0.5' : '1';
    }
  }

  function updateLessonControls() {
    // Show/hide controls based on current lesson
    const patternControls = document.getElementById('patternControls');
    const allControls = ['inputCurrent', 'synapseWeight', 'connectionProb', 'showWeights', 'resetNetwork'];
    
    // Show relevant controls for each lesson
    const lessonControlsMap = {
      1: ['inputCurrent', 'resetNetwork'],
      2: ['inputCurrent', 'synapseWeight', 'showWeights', 'resetNetwork'], 
      3: ['inputCurrent', 'synapseWeight', 'connectionProb', 'resetNetwork'],
      4: ['inputCurrent', 'synapseWeight', 'resetNetwork']
    };

    // Hide all controls first
    allControls.forEach(id => {
      const element = document.getElementById(id);
      if (element && element.closest('.control-group')) {
        element.closest('.control-group').style.display = 'none';
      }
    });

    // Show relevant controls
    lessonControlsMap[currentLesson].forEach(id => {
      const element = document.getElementById(id);
      if (element && element.closest('.control-group')) {
        element.closest('.control-group').style.display = 'block';
      }
    });

    // Show pattern controls only for lesson 4
    if (patternControls) {
      patternControls.style.display = currentLesson === 4 ? 'block' : 'none';
    }

    // Update toggle buttons
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.classList.remove('active');
    });
    const activeToggle = document.getElementById(`lesson${currentLesson}`);
    if (activeToggle) {
      activeToggle.classList.add('active');
    }
  }

  function updateLessonContent() {
    const lessons = {
      1: "Learn how individual neurons integrate input and generate spikes when reaching threshold. Click a neuron to see its voltage trace.",
      2: "Explore how neurons communicate through synaptic connections and network interactions. Adjust weights to see propagation effects.",
      3: "Understand how networks adapt and learn through activity-dependent changes. Experiment with connection density.",
      4: "Discover how spiking networks can detect and learn temporal patterns. Use pattern injection and memory testing."
    };
    
    const contentDiv = document.getElementById('lessonContent');
    if (contentDiv && lessons[currentLesson]) {
      contentDiv.innerHTML = `
        <div class="lesson">
          <strong>Lesson ${currentLesson}</strong><br>
          ${lessons[currentLesson]}
          <br><br>
          <button onclick="document.getElementById('viewLesson').click()" style="background:#f223e0;border:none;color:#fff;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;">
            📖 View Full Lesson
          </button>
        </div>
      `;
    }
  }

  const drawTrace=()=>{
    const c=document.getElementById('trace').getContext('2d'); 
    c.fillStyle='#0f172a'; 
    c.fillRect(0,0,260,150); 
    
    if(selected===null) {
      const voltageValue = document.getElementById('voltageValue');
      if (voltageValue) voltageValue.textContent = '--';
      return;
    }
    
    // Update voltage display
    const currentVoltage = neurons[selected].userData.volt || 0;
    const voltageValue = document.getElementById('voltageValue');
    if (voltageValue) {
      voltageValue.textContent = currentVoltage.toFixed(3);
    }
    
    // Draw threshold line
    c.strokeStyle='#60a5fa'; 
    c.lineWidth=1;
    c.setLineDash([5, 5]);
    const thresholdY = 148 - 1.0 * 130;
    c.beginPath();
    c.moveTo(2, thresholdY);
    c.lineTo(258, thresholdY);
    c.stroke();
    c.setLineDash([]);
    
    // Draw voltage trace
    if(traceBuf.length >= 2) {
      c.strokeStyle='#f223e0'; 
      c.lineWidth=2;
      c.beginPath(); 
      const L=traceBuf.length; 
      for(let i=0;i<L;i++){
        const x=i/(L-1)*256+2;
        const y=148-Math.max(0, Math.min(2, traceBuf[i]))*65;
        i?c.lineTo(x,y):c.moveTo(x,y);
      } 
      c.stroke();
    }
    
    // Add voltage scale labels
    c.fillStyle='#94a3b8';
    c.font='10px Inter';
    c.fillText('2.0V', 5, 15);
    c.fillText('1.0V', 5, 83);
    c.fillText('0.0V', 5, 145);
  };

  // WebSocket message handler
  function handleMessage(e) {
    const d=JSON.parse(e.data);
    if(d.volt){ 
      for(const k in d.volt){ 
        const i=+k; 
        if(neurons[i]){ 
          const v=d.volt[k]; 
          neurons[i].userData.volt=v; 
          if(selected===i){ 
            traceBuf.push(v); 
            if(traceBuf.length>200) traceBuf.shift();
          } 
        } 
      } 
    }
    if(d.spikes){ 
      d.spikes.forEach(s=>{
        const i=s.i; 
        if(!neurons[i]) return; 
        const n=neurons[i]; 
        n.userData.pulse=1.2; 
        
        (outgoing[i]||[]).forEach(seg=>{
          const a=seg*2*3, b=(seg*2+1)*3; 
          col.array[a]=col.array[b]=0.9; 
          col.array[a+1]=col.array[b+1]=0.95; 
          col.array[a+2]=col.array[b+2]=1.0;
        }); 
        col.needsUpdate=true;
      }); 
    }
    // FIXED: Handle connection visualization
    if(d.cmd === "showConnections" && d.connections) {
      console.log(`Received ${d.connections.length} connections`);
      updateConnectionVisualization(d.connections);
    }
  }

  // FIXED: Add connection visualization function
  function updateConnectionVisualization(connections) {
    // Clear existing visualization
    connectionLabels.forEach(label => {
      if (label.parent) label.parent.remove(label);
    });
    connectionLabels = [];

    if (!showWeights || connections.length === 0) return;

    // Create new connection geometry
    const positions = [];
    const colors = [];
    
    connections.forEach(conn => {
      if (conn.from < neurons.length && conn.to < neurons.length) {
        const fromPos = neurons[conn.from].position;
        const toPos = neurons[conn.to].position;
        
        positions.push(fromPos.x, fromPos.y, fromPos.z);
        positions.push(toPos.x, toPos.y, toPos.z);
        
        // Color based on connection type
        if (conn.type === 'excitatory') {
          colors.push(0.2, 0.6, 1.0, 0.2, 0.6, 1.0);  // Blue
        } else {
          colors.push(1.0, 0.3, 0.3, 1.0, 0.3, 0.3);  // Red for inhibitory
        }
        
        // Add weight label at midpoint
        const midPoint = new THREE.Vector3(
          (fromPos.x + toPos.x) / 2,
          (fromPos.y + toPos.y) / 2,
          (fromPos.z + toPos.z) / 2
        );

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 32;
        
        context.fillStyle = conn.type === 'excitatory' ? '#60a5fa' : '#ef4444';
        context.font = '10px Inter';
        context.textAlign = 'center';
        context.fillText(conn.weight.toFixed(3), 32, 20);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ 
          map: texture, 
          transparent: true,
          opacity: 0.7
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(midPoint);
        sprite.scale.set(3, 1.5, 1);
        
        scene.add(sprite);
        connectionLabels.push(sprite);
      }
    });
    
    // Update geometry
    connGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    connGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    console.log(`Visualized ${connections.length} realistic connections`);
  }

  // Educational controls setup
  function setupEducationalControls() {
    // Lesson dropdown functionality
    const lessonSelect = document.getElementById('lessonSelect');
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    const viewBtn = document.getElementById('viewLesson');
    
    if (lessonSelect) {
      lessonSelect.addEventListener('change', (e) => {
        currentLesson = parseInt(e.target.value);
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    }
    
    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        if (currentLesson > 1) {
          currentLesson--;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }
    
    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        if (currentLesson < 4) {
          currentLesson++;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }

    if (viewBtn) {
      viewBtn.addEventListener('click', () => {
        openLessonModal();
      });
    }

    // Modal controls
    const closeModal = document.getElementById('closeModal');
    const modal = document.getElementById('lessonModal');
    
    if (closeModal) {
      closeModal.addEventListener('click', () => {
        modal.style.display = 'none';
      });
    }

    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });
    }

    // Legacy lesson toggle buttons (keep for backwards compatibility)
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.toggle').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentLesson = parseInt(btn.id.replace('lesson', ''));
        lessonSelect.value = currentLesson;
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    });

    // Input controls
    const inputCurrent = document.getElementById('inputCurrent');
    const inputValue = document.getElementById('inputValue');
    if (inputCurrent && inputValue) {
      inputCurrent.addEventListener('input', () => {
        inputValue.textContent = inputCurrent.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setInput', value: parseFloat(inputCurrent.value)}));
        }
      });
    }

    const synapseWeight = document.getElementById('synapseWeight');
    const weightValue = document.getElementById('weightValue');
    if (synapseWeight && weightValue) {
      synapseWeight.addEventListener('input', () => {
        weightValue.textContent = synapseWeight.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setWeight', value: parseFloat(synapseWeight.value)}));
        }
      });
    }

    const connectionProb = document.getElementById('connectionProb');
    const probValue = document.getElementById('probValue');
    if (connectionProb && probValue) {
      connectionProb.addEventListener('input', () => {
        probValue.textContent = connectionProb.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setConnectionProb', value: parseFloat(connectionProb.value)}));
        }
      });
    }

    // Buttons
    const resetBtn = document.getElementById('resetNetwork');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'reset'}));
        }
      });
    }

    const showWeightsBtn = document.getElementById('showWeights');
    if (showWeightsBtn) {
      showWeightsBtn.addEventListener('click', () => {
        showWeights = !showWeights;
        showWeightsBtn.textContent = showWeights ? 'Hide Weights' : 'Show Weights';
        showWeightsBtn.classList.toggle('on', showWeights);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'toggleWeights'}));
        }
        
        // If hiding weights, clear labels immediately
        if (!showWeights) {
          connectionLabels.forEach(label => {
            if (label.parent) label.parent.remove(label);
          });
          connectionLabels = [];
          
          // Reset connection line colors to subtle
          if (connGeom && col) {
            const colors = connGeom.getAttribute('color');
            for(let i = 0; i < colors.array.length; i += 3) {
              colors.array[i] = 0.05;
              colors.array[i+1] = 0.08;
              colors.array[i+2] = 0.12;
            }
            colors.needsUpdate = true;
          }
        }
        
        console.log(`Weights visibility: ${showWeights}`);
      });
    }

    // Pattern controls for lesson 4
    const injectBtn = document.getElementById('injectPattern');
    const testBtn = document.getElementById('testMemory');
    
    if (injectBtn) {
      injectBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'injectPattern'}));
        }
      });
    }

    if (testBtn) {
      testBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'testMemory'}));
        }
      });
    }
  }

  function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    
    if (prevBtn) {
      prevBtn.disabled = currentLesson === 1;
      prevBtn.style.opacity = currentLesson === 1 ? '0.5' : '1';
    }
    
    if (nextBtn) {
      nextBtn.disabled = currentLesson === 4;
      nextBtn.style.opacity = currentLesson === 4 ? '0.5' : '1';
    }
  }

  function updateLessonControls() {
    // Show/hide controls based on current lesson
    const patternControls = document.getElementById('patternControls');
    const allControls = ['inputCurrent', 'synapseWeight', 'connectionProb', 'showWeights', 'resetNetwork'];
    
    // Show relevant controls for each lesson
    const lessonControlsMap = {
      1: ['inputCurrent', 'resetNetwork'],
      2: ['inputCurrent', 'synapseWeight', 'showWeights', 'resetNetwork'], 
      3: ['inputCurrent', 'synapseWeight', 'connectionProb', 'resetNetwork'],
      4: ['inputCurrent', 'synapseWeight', 'resetNetwork']
    };

    // Hide all controls first
    allControls.forEach(id => {
      const element = document.getElementById(id);
      if (element && element.closest('.control-group')) {
        element.closest('.control-group').style.display = 'none';
      }
    });

    // Show relevant controls
    lessonControlsMap[currentLesson].forEach(id => {
      const element = document.getElementById(id);
      if (element && element.closest('.control-group')) {
        element.closest('.control-group').style.display = 'block';
      }
    });

    // Show pattern controls only for lesson 4
    if (patternControls) {
      patternControls.style.display = currentLesson === 4 ? 'block' : 'none';
    }

    // Update toggle buttons
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.classList.remove('active');
    });
    const activeToggle = document.getElementById(`lesson${currentLesson}`);
    if (activeToggle) {
      activeToggle.classList.add('active');
    }
  }

  function updateLessonContent() {
    const lessons = {
      1: "Learn how individual neurons integrate input and generate spikes when reaching threshold. Click a neuron to see its voltage trace.",
      2: "Explore how neurons communicate through synaptic connections and network interactions. Adjust weights to see propagation effects.",
      3: "Understand how networks adapt and learn through activity-dependent changes. Experiment with connection density.",
      4: "Discover how spiking networks can detect and learn temporal patterns. Use pattern injection and memory testing."
    };
    
    const contentDiv = document.getElementById('lessonContent');
    if (contentDiv && lessons[currentLesson]) {
      contentDiv.innerHTML = `
        <div class="lesson">
          <strong>Lesson ${currentLesson}</strong><br>
          ${lessons[currentLesson]}
          <br><br>
          <button onclick="document.getElementById('viewLesson').click()" style="background:#f223e0;border:none;color:#fff;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;">
            📖 View Full Lesson
          </button>
        </div>
      `;
    }
  }

  const drawTrace=()=>{
    const c=document.getElementById('trace').getContext('2d'); 
    c.fillStyle='#0f172a'; 
    c.fillRect(0,0,260,150); 
    
    if(selected===null) {
      const voltageValue = document.getElementById('voltageValue');
      if (voltageValue) voltageValue.textContent = '--';
      return;
    }
    
    // Update voltage display
    const currentVoltage = neurons[selected].userData.volt || 0;
    const voltageValue = document.getElementById('voltageValue');
    if (voltageValue) {
      voltageValue.textContent = currentVoltage.toFixed(3);
    }
    
    // Draw threshold line
    c.strokeStyle='#60a5fa'; 
    c.lineWidth=1;
    c.setLineDash([5, 5]);
    const thresholdY = 148 - 1.0 * 130;
    c.beginPath();
    c.moveTo(2, thresholdY);
    c.lineTo(258, thresholdY);
    c.stroke();
    c.setLineDash([]);
    
    // Draw voltage trace
    if(traceBuf.length >= 2) {
      c.strokeStyle='#f223e0'; 
      c.lineWidth=2;
      c.beginPath(); 
      const L=traceBuf.length; 
      for(let i=0;i<L;i++){
        const x=i/(L-1)*256+2;
        const y=148-Math.max(0, Math.min(2, traceBuf[i]))*65;
        i?c.lineTo(x,y):c.moveTo(x,y);
      } 
      c.stroke();
    }
    
    // Add voltage scale labels
    c.fillStyle='#94a3b8';
    c.font='10px Inter';
    c.fillText('2.0V', 5, 15);
    c.fillText('1.0V', 5, 83);
    c.fillText('0.0V', 5, 145);
  };

  // WebSocket message handler
  function handleMessage(e) {
    const d=JSON.parse(e.data);
    if(d.volt){ 
      for(const k in d.volt){ 
        const i=+k; 
        if(neurons[i]){ 
          const v=d.volt[k]; 
          neurons[i].userData.volt=v; 
          if(selected===i){ 
            traceBuf.push(v); 
            if(traceBuf.length>200) traceBuf.shift();
          } 
        } 
      } 
    }
    if(d.spikes){ 
      d.spikes.forEach(s=>{
        const i=s.i; 
        if(!neurons[i]) return; 
        const n=neurons[i]; 
        n.userData.pulse=1.2; 
        
        (outgoing[i]||[]).forEach(seg=>{
          const a=seg*2*3, b=(seg*2+1)*3; 
          col.array[a]=col.array[b]=0.9; 
          col.array[a+1]=col.array[b+1]=0.95; 
          col.array[a+2]=col.array[b+2]=1.0;
        }); 
        col.needsUpdate=true;
      }); 
    }
    // FIXED: Handle connection visualization
    if(d.cmd === "showConnections" && d.connections) {
      console.log(`Received ${d.connections.length} connections`);
      updateConnectionVisualization(d.connections);
    }
  }

  // FIXED: Add connection visualization function
  function updateConnectionVisualization(connections) {
    // Clear existing visualization
    connectionLabels.forEach(label => {
      if (label.parent) label.parent.remove(label);
    });
    connectionLabels = [];

    if (!showWeights || connections.length === 0) return;

    // Create new connection geometry
    const positions = [];
    const colors = [];
    
    connections.forEach(conn => {
      if (conn.from < neurons.length && conn.to < neurons.length) {
        const fromPos = neurons[conn.from].position;
        const toPos = neurons[conn.to].position;
        
        positions.push(fromPos.x, fromPos.y, fromPos.z);
        positions.push(toPos.x, toPos.y, toPos.z);
        
        // Color based on connection type
        if (conn.type === 'excitatory') {
          colors.push(0.2, 0.6, 1.0, 0.2, 0.6, 1.0);  // Blue
        } else {
          colors.push(1.0, 0.3, 0.3, 1.0, 0.3, 0.3);  // Red for inhibitory
        }
        
        // Add weight label at midpoint
        const midPoint = new THREE.Vector3(
          (fromPos.x + toPos.x) / 2,
          (fromPos.y + toPos.y) / 2,
          (fromPos.z + toPos.z) / 2
        );

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 32;
        
        context.fillStyle = conn.type === 'excitatory' ? '#60a5fa' : '#ef4444';
        context.font = '10px Inter';
        context.textAlign = 'center';
        context.fillText(conn.weight.toFixed(3), 32, 20);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ 
          map: texture, 
          transparent: true,
          opacity: 0.7
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(midPoint);
        sprite.scale.set(3, 1.5, 1);
        
        scene.add(sprite);
        connectionLabels.push(sprite);
      }
    });
    
    // Update geometry
    connGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    connGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    console.log(`Visualized ${connections.length} realistic connections`);
  }

  // Educational controls setup
  function setupEducationalControls() {
    // Lesson dropdown functionality
    const lessonSelect = document.getElementById('lessonSelect');
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    const viewBtn = document.getElementById('viewLesson');
    
    if (lessonSelect) {
      lessonSelect.addEventListener('change', (e) => {
        currentLesson = parseInt(e.target.value);
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    }
    
    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        if (currentLesson > 1) {
          currentLesson--;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }
    
    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        if (currentLesson < 4) {
          currentLesson++;
          lessonSelect.value = currentLesson;
          updateLessonContent();
          updateLessonControls();
          updateNavigationButtons();
        }
      });
    }

    if (viewBtn) {
      viewBtn.addEventListener('click', () => {
        openLessonModal();
      });
    }

    // Modal controls
    const closeModal = document.getElementById('closeModal');
    const modal = document.getElementById('lessonModal');
    
    if (closeModal) {
      closeModal.addEventListener('click', () => {
        modal.style.display = 'none';
      });
    }

    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });
    }

    // Legacy lesson toggle buttons (keep for backwards compatibility)
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.toggle').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentLesson = parseInt(btn.id.replace('lesson', ''));
        lessonSelect.value = currentLesson;
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    });

    // Input controls
    const inputCurrent = document.getElementById('inputCurrent');
    const inputValue = document.getElementById('inputValue');
    if (inputCurrent && inputValue) {
      inputCurrent.addEventListener('input', () => {
        inputValue.textContent = inputCurrent.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setInput', value: parseFloat(inputCurrent.value)}));
        }
      });
    }

    const synapseWeight = document.getElementById('synapseWeight');
    const weightValue = document.getElementById('weightValue');
    if (synapseWeight && weightValue) {
      synapseWeight.addEventListener('input', () => {
        weightValue.textContent = synapseWeight.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setWeight', value: parseFloat(synapseWeight.value)}));
        }
      });
    }

    const connectionProb = document.getElementById('connectionProb');
    const probValue = document.getElementById('probValue');
    if (connectionProb && probValue) {
      connectionProb.addEventListener('input', () => {
        probValue.textContent = connectionProb.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setConnectionProb', value: parseFloat(connectionProb.value)}));
        }
      });
    }

    // Buttons
    const resetBtn = document.getElementById('resetNetwork');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'reset'}));
        }
      });
    }

    const showWeightsBtn = document.getElementById('showWeights');
    if (showWeightsBtn) {
      showWeightsBtn.addEventListener('click', () => {
        showWeights = !showWeights;
        showWeightsBtn.textContent = showWeights ? 'Hide Weights' : 'Show Weights';
        showWeightsBtn.classList.toggle('on', showWeights);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'toggleWeights'}));
        }
        
        // If hiding weights, clear labels immediately
        if (!showWeights) {
          connectionLabels.forEach(label => {
            if (label.parent) label.parent.remove(label);
          });
          connectionLabels = [];
          
          // Reset connection line colors to subtle
          if (connGeom && col) {
            const colors = connGeom.getAttribute('color');
            for(let i = 0; i < colors.array.length; i += 3) {
              colors.array[i] = 0.05;
              colors.array[i+1] = 0.08;
              colors.array[i+2] = 0.12;
            }
            colors.needsUpdate = true;
          }
        }
        
        console.log(`Weights visibility: ${showWeights}`);
      });
    }

    // Pattern controls for lesson 4
    const injectBtn = document.getElementById('injectPattern');
    const testBtn = document.getElementById('testMemory');
    
    if (injectBtn) {
      injectBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'injectPattern'}));
        }
      });
    }

    if (testBtn) {
      testBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'testMemory'}));
        }
      });
    }
  }

  // Enhanced firing effects with premium violet colors
  function animate(){
    requestAnimationFrame(animate);
    
    for(let i = 0; i < neurons.length; i++){
      const n = neurons[i], g = glows[i], u = n.userData;
      
      if(u.pulse > 0){
        u.pulse *= 0.88;
        const p = u.pulse / 1.2;
        
        if(u.type === 'excitatory'){
          // Violet firing for excitatory
          n.material.emissive.setRGB(p * 0.95, p * 0.15, p * 0.95);
          g.material.color.setRGB(0.95, 0.15 + p * 0.85, 0.95);
        } else {
          // Orange firing for inhibitory
          n.material.emissive.setRGB(p * 1.0, p * 0.5, p * 0.1);
          g.material.color.setRGB(1.0, 0.5 + p * 0.5, 0.1);
        }
        
        g.material.opacity = p * 0.9;
        g.scale.setScalar((u.type === 'excitatory' ? 5 : 4) + p * 3);
      } else {
        // Reset to base colors
        if(u.type === 'excitatory'){
          g.material.color.setRGB(0.23, 0.51, 0.98);
        } else {
          g.material.color.setRGB(0.94, 0.26, 0.26);
        }
      }
      
      // Voltage-based color modulation
      const v = Math.max(0, Math.min(1, u.volt || 0));
      if(u.type === 'excitatory'){
        const hue = 0.62 - v * 0.15;  // Blue to violet
        n.material.color.setHSL(hue, 0.85 + v * 0.1, 0.35 + v * 0.4);
      } else {
        const hue = 0.0 + v * 0.08;   // Red to orange
        n.material.color.setHSL(hue, 0.9, 0.4 + v * 0.3);
      }
      
      n.material.metalness = 0.9 + v * 0.1;
      n.material.roughness = 0.1 - v * 0.05;
    }
    
    // Premium connection lighting effects
    if (connGeom && col) {
      const colors=connGeom.getAttribute('color');
      for(let i=0;i<colors.array.length;i+=3){
        if (showWeights) {
          // Keep connections bright when showing weights
          colors.array[i] = Math.max(0.3, colors.array[i] * 0.999);
          colors.array[i+1] = Math.max(0.5, colors.array[i+1] * 0.999);
          colors.array[i+2] = Math.max(0.8, colors.array[i+2] * 0.999);
        } else {
          // Very subtle connection fade for premium look
          colors.array[i]=Math.max(0.02, colors.array[i]*0.995);
          colors.array[i+1]=Math.max(0.04, colors.array[i+1]*0.995);
          colors.array[i+2]=Math.max(0.08, colors.array[i+2]*0.995);
        }
      }
      colors.needsUpdate=true;
    }
    
    drawTrace();
    renderer.render(scene,camera);
  }

  // UI Controls - FIXED pause and speed functionality
  const btn=document.getElementById('play'), rng=document.getElementById('speed');
  
  // FIXED: Proper pause/play toggle
  btn.onclick=()=>{
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    
    // Toggle the button state first
    const isCurrentlyPaused = btn.classList.contains('on');
    
    if (isCurrentlyPaused) {
      // Currently showing "Pause" (running), so pause it
      btn.classList.remove('on');
      btn.textContent = 'Play';
      ws.send(JSON.stringify({cmd:'pause'}));
      console.log('Pausing simulation');
    } else {
      // Currently showing "Play" (paused), so resume it
      btn.classList.add('on');
      btn.textContent = 'Pause';
      ws.send(JSON.stringify({cmd:'play'}));
      console.log('Resuming simulation');
    }
  };
  
  // FIXED: Speed control that actually affects simulation speed
  rng.oninput=()=>{
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const speed = parseInt(rng.value, 10);
    // Invert the scale: higher slider value = faster simulation = lower dt_ms
    const dt_ms = Math.max(5, 200 - speed); // 10-150 becomes 195-50ms
    ws.send(JSON.stringify({cmd:'speed', dt_ms: dt_ms}));
    console.log(`Speed set to ${speed} (${dt_ms}ms timestep)`);
  };

  // Initialize everything
  console.log('Initializing educational controls...');
  setupEducationalControls();
  updateLessonContent();
  updateLessonControls();
  updateNavigationButtons();
  
  console.log('Connecting to WebSocket...');
  connectWS();
  
  console.log('Starting animation loop...');
  animate();

  // Handle window resize
  addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });

})();
</script>
</body>
</html>
