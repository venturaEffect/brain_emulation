<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>SNN Visualizer — SYNTHETIC-2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #0a0c12;
        --panel: #12151c;
        --text: #c4d1e0;
        --muted: #6b7280;
        --edge: #1e293b;
        --edgeHot: #3b82f6;
        --node: #60a5fa;
        --hot: #f59e0b;
        --pulse: #ef4444;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font: 14px/1.5 Inter, system-ui, Helvetica, Arial;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #overlay {
        pointer-events: none;
        position: fixed;
        inset: 0;
        background: radial-gradient(
            1400px 900px at 30% 0%,
            #1e293b22,
            transparent 70%
          ),
          radial-gradient(1000px 600px at 80% 100%, #1e1b4b22, transparent 60%);
      }
      #hud {
        position: fixed;
        left: 20px;
        top: 20px;
        display: flex;
        gap: 14px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 12px 16px;
        border-radius: 16px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }
      .btn {
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        background: rgba(12, 8, 18, 0.9);
        color: #f3f2ff;
        cursor: pointer;
        padding: 10px 14px;
        transition: all 0.12s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      }
      .btn.on {
        background: #ff00d6;
        color: #06010a;
        border-color: rgba(255, 0, 214, 0.35);
        box-shadow: 0 0 18px rgba(255, 0, 214, 0.12);
      }
      .range {
        accent-color: #ff00d6;
      }
      #panel {
        position: fixed;
        right: 20px;
        top: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      }
      #panel h4 {
        margin: 0 0 8px;
        font-weight: 600;
        color: #f1f5f9;
        font-size: 15px;
      }
      #trace {
        width: 100%;
        height: 150px;
        background: #0f172a;
        border-radius: 12px;
        border: 1px solid #1e293b;
      }
      #err {
        position: fixed;
        left: 20px;
        bottom: 20px;
        background: #dc2626;
        color: #fff;
        padding: 10px 14px;
        border-radius: 12px;
        display: none;
      }
      #controls {
        position: fixed;
        left: 20px;
        bottom: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        max-height: 300px;
        overflow-y: auto;
      }
      .control-group {
        margin-bottom: 12px;
      }
      .control-group label {
        display: block;
        margin-bottom: 4px;
        font-size: 13px;
        color: #94a3b8;
      }
      .control-group input[type="range"] {
        width: 100%;
        accent-color: #3b82f6;
      }
      .toggle {
        background: #1e293b;
        border: 1px solid #334155;
        padding: 6px 12px;
        border-radius: 8px;
        cursor: pointer;
        display: inline-block;
        margin: 2px;
      }
      .toggle.active {
        background: #1e40af;
        color: #fff;
      }
      #info {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 320px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        font-size: 13px;
        line-height: 1.6;
      }
      .lesson {
        background: #0f172a;
        padding: 12px;
        border-radius: 8px;
        margin: 8px 0;
        border-left: 3px solid #3b82f6;
      }

      /* Panel borders and consistent dark panels */
      #hud,
      #panel,
      #controls,
      #info,
      #lessonPanel,
      #lessonModal > div {
        background: #0b0c0f;
        border: 1px solid rgba(200, 200, 200, 0.06); /* very thin grey border */
      }

      /* Neon buttons and active state */
      .btn {
        border: 1px solid rgba(255, 255, 255, 0.06);
        background: rgba(12, 8, 18, 0.9); /* dark base */
        color: #f3f2ff;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
        transition: all 0.12s ease;
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      }
      .btn.on {
        background: #ff00d6; /* neon magenta */
        color: #06010a;
        border-color: rgba(255, 0, 214, 0.35);
        box-shadow: 0 0 18px rgba(255, 0, 214, 0.12);
      }

      /* Range neon accent (magenta) */
      .range {
        accent-color: #ff00d6;
      }
      input[type="range"]::-webkit-slider-thumb {
        background: #ff00d6;
        box-shadow: 0 0 8px rgba(255, 0, 214, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      input[type="range"]::-moz-range-thumb {
        background: #ff00d6;
        box-shadow: 0 0 8px rgba(255, 0, 214, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      /* Lesson full content: make text clear and ensure background transparent/dark + neon title */
      #lessonFullContent {
        color: #e6e9ef;
        background: transparent;
      }
      #lessonFullContent h1,
      #lessonFullContent h2,
      #lessonFullContent h3,
      #lessonFullContent strong {
        background: transparent !important;
        color: #ff9bf0 !important; /* neon magenta title color */
        margin: 0 0 8px 0;
      }
      /* Small lesson card title emphasis */
      .lesson strong {
        color: #ff9bf0;
      }

      /* Lesson iframe (full lesson) */
      #lessonModal > div {
        overflow: hidden;
      }
      #lessonFrame {
        width: 100%;
        height: 60vh;
        border: none;
        border-radius: 10px;
        background: transparent;
        display: block;
      }
      #lessonFallback {
        padding: 12px 0;
        color: #cbd5e1;
        line-height: 1.6;
      }

      /* Navigation controls HUD */
      #navControls {
        position: fixed;
        right: 20px;
        top: 200px;
        background: rgba(12, 8, 18, 0.9);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 12px;
        padding: 12px;
        color: #f3f2ff;
        font-size: 11px;
        line-height: 1.4;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        max-width: 180px;
      }

      #navControls h5 {
        margin: 0 0 8px 0;
        color: #ff9bf0;
        font-size: 12px;
        font-weight: 600;
      }

      .nav-tip {
        margin: 4px 0;
        color: #94a3b8;
      }
      /* Selected neuron info panel */
      #neuronInfo {
        position: fixed;
        left: 20px;
        top: 300px;
        width: 280px;
        background: rgba(12, 8, 18, 0.95);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 12px;
        padding: 14px;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        display: none;
      }

      #neuronInfo h5 {
        margin: 0 0 8px 0;
        color: #ff9bf0;
        font-size: 13px;
        font-weight: 600;
      }

      .neuron-detail {
        margin: 6px 0;
        font-size: 12px;
        color: #e6f7ff;
      }

      .neuron-detail strong {
        color: #00f0ff;
      }

      /* Zoom level indicator */
      #zoomLevel {
        position: fixed;
        right: 20px;
        bottom: 120px;
        background: rgba(12, 8, 18, 0.8);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 11px;
        color: #94a3b8;
      }
    </style>
  </head>
  <body>
    <div id="overlay"></div>
    <div id="hud">
      <div style="font-weight: 600; color: #f1f5f9">SNN • Neural Network</div>
      <button id="play" class="btn on">Pause</button>
      <label style="color: #94a3b8"
        >Speed
        <input
          id="speed"
          class="range"
          type="range"
          min="10"
          max="150"
          value="50"
      /></label>
    </div>

    <div id="panel">
      <h4 id="sel">Select Neuron</h4>
      <div style="margin-bottom: 8px; font-size: 12px; color: #94a3b8">
        Voltage:
        <span id="voltageValue" style="color: #f223e0; font-weight: bold"
          >--</span
        >
        <span style="margin-left: 10px"
          >Threshold: <span style="color: #60a5fa">1.0</span></span
        >
      </div>
      <canvas id="trace" width="260" height="150"></canvas>
    </div>

    <!-- Re-added lesson panel (restore missing settings UI) -->
    <div
      id="lessonPanel"
      style="
        position: fixed;
        left: 20px;
        top: 80px;
        display: flex;
        gap: 12px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 10px 16px;
        border-radius: 12px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      "
    >
      <label for="lessonSelect" style="color: #94a3b8; font-weight: 500"
        >Lesson:</label
      >
      <select id="lessonSelect">
        <option value="1">Lesson 1: Basic Spike Dynamics</option>
        <option value="2">Lesson 2: Synaptic Transmission</option>
        <option value="3">Lesson 3: Network Plasticity</option>
        <option value="4">Lesson 4: Pattern Recognition</option>
      </select>
      <div style="display: flex; gap: 8px">
        <button
          id="prevLesson"
          class="btn"
          style="padding: 6px 10px; font-size: 12px"
        >
          ← Prev
        </button>
        <button
          id="nextLesson"
          class="btn"
          style="padding: 6px 10px; font-size: 12px"
        >
          Next →
        </button>
        <button
          id="viewLesson"
          class="btn"
          style="
            padding: 6px 10px;
            font-size: 12px;
            background: #f223e0;
            color: #fff;
          "
        >
          📖 View Full
        </button>
      </div>
    </div>

    <div id="controls">
      <h4 style="margin: 0 0 12px; color: #f1f5f9">Learning Controls</h4>
      <div class="control-group">
        <label>Lesson Mode:</label>
        <div style="display: flex; gap: 6px; flex-wrap: wrap">
          <div class="toggle active" id="lesson1">Basic Spikes</div>
          <div class="toggle" id="lesson2">Synapses</div>
          <div class="toggle" id="lesson3">Plasticity</div>
          <div class="toggle" id="lesson4">Patterns</div>
        </div>
      </div>

      <div class="control-group">
        <label for="inputCurrent"
          >Input Current: <span id="inputValue">0.5</span></label
        >
        <input
          type="range"
          id="inputCurrent"
          min="0"
          max="2"
          step="0.1"
          value="0.5"
        />
      </div>

      <div class="control-group">
        <label for="synapseWeight"
          >Synaptic Weight: <span id="weightValue">0.2</span></label
        >
        <input
          type="range"
          id="synapseWeight"
          min="0"
          max="1"
          step="0.05"
          value="0.2"
        />
      </div>

      <div class="control-group">
        <label for="networkSize"
          >Network Size: <span id="sizeValue">50</span></label
        >
        <input
          type="range"
          id="networkSize"
          min="10"
          max="100"
          step="5"
          value="50"
        />
      </div>

      <div class="control-group">
        <label for="connectionProb"
          >Connection Probability: <span id="probValue">0.045</span></label
        >
        <input
          type="range"
          id="connectionProb"
          min="0"
          max="0.2"
          step="0.005"
          value="0.045"
        />
      </div>

      <button id="resetNetwork" class="btn">Reset Network</button>
      <button id="showWeights" class="btn">Show Weights</button>

      <div class="control-group" id="patternControls" style="display: none">
        <button
          id="injectPattern"
          class="btn"
          style="width: 100%; margin-bottom: 8px"
        >
          Inject Pattern
        </button>
        <button id="testMemory" class="btn" style="width: 100%">
          Test Memory
        </button>
      </div>
    </div>
    <div
      id="lessonModal"
      style="
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(4px);
        z-index: 1000;
        overflow-y: auto;
      "
    >
      <div
        style="
          max-width: 800px;
          margin: 40px auto;
          background: #12151c;
          border: 1px solid #334155;
          border-radius: 16px;
          padding: 18px 20px;
          position: relative;
        "
      >
        <button
          id="closeModal"
          style="
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 24px;
            cursor: pointer;
          "
        >
          ×
        </button>
        <iframe
          id="lessonFrame"
          src=""
          title="Lesson content"
          sandbox="allow-same-origin allow-scripts allow-forms"
        ></iframe>
        <div id="lessonFallback" style="display: none"></div>
      </div>
    </div>

    <!-- Add navigation help panel -->
    <div id="navControls">
      <h5>🎮 Navigation</h5>
      <div class="nav-tip"><strong>Mouse Drag:</strong> Rotate view</div>
      <div class="nav-tip"><strong>Mouse Wheel:</strong> Zoom in/out</div>
      <div class="nav-tip"><strong>Right Click:</strong> Pan camera</div>
      <div class="nav-tip"><strong>Click Neuron:</strong> Inspect details</div>
      <div class="nav-tip"><strong>Double Click:</strong> Focus on neuron</div>
      <div class="nav-tip"><strong>Space:</strong> Reset view</div>
    </div>

    <!-- Selected neuron detailed info -->
    <div id="neuronInfo">
      <h5>🔍 Neuron Inspector</h5>
      <div class="neuron-detail">
        <strong>ID:</strong> <span id="neuronId">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Type:</strong> <span id="neuronType">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Cluster:</strong> <span id="neuronCluster">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Voltage:</strong> <span id="neuronVoltage">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Last Spike:</strong> <span id="neuronLastSpike">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Connections In:</strong> <span id="neuronConnIn">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Connections Out:</strong> <span id="neuronConnOut">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Activity Rate:</strong> <span id="neuronActivity">--</span>
      </div>
    </div>

    <!-- Zoom level indicator -->
    <div id="zoomLevel">Zoom: <span id="zoomValue">100%</span></div>

    <div id="info">
      <h4 style="margin: 0 0 8px; color: #f1f5f9">Learning Guide</h4>
      <div id="lessonContent">
        <div class="lesson">
          <strong>Lesson 1: Basic Spikes</strong><br />
          Each neuron accumulates voltage over time. When it reaches threshold
          (v=1), it fires a spike and resets to 0.
        </div>
      </div>
    </div>
    <div id="err"></div>

    <script
      src="https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.min.js"
      onerror="loadThreeFallback()"
    ></script>
    <script>
      function loadThreeFallback() {
        console.log("CDN failed, trying alternative sources...");

        // Try unpkg as secondary CDN
        const script1 = document.createElement("script");
        script1.src = "https://unpkg.com/three@0.165.0/build/three.min.js";
        script1.onerror = () => {
          console.log("Second CDN failed, trying local file...");

          // Try local file as last resort
          const script2 = document.createElement("script");
          script2.src = "./three.min.js";
          script2.onerror = () => {
            const errEl = document.getElementById("err");
            errEl.textContent =
              "Failed to load Three.js. Neural network visualization unavailable.";
            errEl.style.display = "block";
          };
          script2.onload = () => {
            console.log("Local Three.js loaded");
            initApp();
          };
          document.head.appendChild(script2);
        };
        script1.onload = () => {
          console.log("Backup CDN Three.js loaded");
          initApp();
        };
        document.head.appendChild(script1);
      }

      // Wait for Three.js to load
      function initApp() {
        console.log("Initializing app...");

        const showErr = (m) => {
          const e = document.getElementById("err");
          e.textContent = m;
          e.style.display = "block";
        };

        if (!window.THREE) {
          showErr("Three.js is still loading... Please wait.");
          setTimeout(initApp, 1000); // Check again in 1 second
          return;
        }

        console.log("Three.js detected, starting neural network...");

        // Hide any loading errors
        document.getElementById("err").style.display = "none";

        // WebSocket connection
        let ws;
        function connectWS() {
          try {
            ws = new WebSocket("ws://localhost:8766");
            ws.onopen = () => {
              console.log("Connected to SNN server");
              document.getElementById("err").style.display = "none";
            };
            ws.onerror = () =>
              showErr("Connection failed. Make sure server.py is running.");
            ws.onclose = () => setTimeout(connectWS, 2000);
            ws.onmessage = handleMessage;
          } catch (error) {
            showErr("Failed to connect to server");
          }
        }

        // Constants
        const NUM = 50;
        const CLUSTER_COLORS = [
          {
            primary: new THREE.Color(0.0, 0.8, 1.0),
            glow: new THREE.Color(0.3, 0.9, 1.0),
          },
          {
            primary: new THREE.Color(1.0, 0.2, 0.8),
            glow: new THREE.Color(1.0, 0.5, 0.9),
          },
          {
            primary: new THREE.Color(0.9, 1.0, 0.0),
            glow: new THREE.Color(1.0, 1.0, 0.4),
          },
          {
            primary: new THREE.Color(1.0, 0.5, 0.0),
            glow: new THREE.Color(1.0, 0.7, 0.3),
          },
          {
            primary: new THREE.Color(1.0, 0.0, 0.4),
            glow: new THREE.Color(1.0, 0.3, 0.6),
          },
        ];

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(
          45,
          innerWidth / innerHeight,
          0.1,
          2000
        );
        camera.position.set(0, 0, 120);

        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          powerPreference: "high-performance",
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x0a0a0a, 0.3));
        const keyLight = new THREE.PointLight(0x4080ff, 2.0, 200);
        keyLight.position.set(80, 80, 80);
        scene.add(keyLight);

        // Accent lights
        CLUSTER_COLORS.forEach((cluster, i) => {
          const angle = (i / CLUSTER_COLORS.length) * Math.PI * 2;
          const light = new THREE.PointLight(
            cluster.primary.getHex(),
            0.85,
            200
          );
          light.position.set(
            Math.cos(angle) * 90,
            Math.sin(angle) * 90,
            Math.sin(angle * 2) * 40
          );
          scene.add(light);
        });

        // Global variables
        const neurons = [],
          glows = [],
          connectionLabels = [];
        let connections = [];
        let connGeom, col, lines;
        let selected = null,
          traceBuf = [];
        let showWeights = false;

        // Camera controls - FIXED
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let cameraDistance = 120;
        let cameraTheta = 0;
        let cameraPhi = Math.PI / 2;
        let isDragging = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let selectedNeuron = null;
        let neuronActivityHistory = new Map();

        // Lesson content and current lesson
        const lessonContent = {
          1: {
            title: "Basic Spike Dynamics",
            content: `Each neuron integrates input until threshold (v=1). When threshold is reached, it emits a spike and resets.`,
          },
          2: {
            title: "Synaptic Transmission",
            content: `Synapses transmit spikes between neurons. Excitatory synapses increase voltage; inhibitory decrease it.`,
          },
          3: {
            title: "Network Plasticity",
            content: `Plasticity mechanisms change synaptic strengths over time through Hebbian learning.`,
          },
          4: {
            title: "Pattern Recognition",
            content: `Networks can store and recall patterns through strengthened connection pathways.`,
          },
        };
        let currentLesson = 1;
        // Draw trace function
        function drawTrace() {
          const canvas = document.getElementById("trace");
          if (!canvas || !traceBuf.length) return;

          const ctx = canvas.getContext("2d");
          const w = canvas.width,
            h = canvas.height;

          ctx.fillStyle = "#0f172a";
          ctx.fillRect(0, 0, w, h);

          // Draw threshold line
          ctx.strokeStyle = "#60a5fa";
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(0, h * 0.2);
          ctx.lineTo(w, h * 0.2);
          ctx.stroke();
          ctx.setLineDash([]);

          // Draw voltage trace
          if (traceBuf.length > 1) {
            ctx.strokeStyle = "#f223e0";
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < traceBuf.length; i++) {
              const x = (i / (traceBuf.length - 1)) * w;
              const y = h - traceBuf[i] * h * 0.8;

              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.stroke();
          }

          // Update voltage value display
          if (selectedNeuron) {
            const voltageEl = document.getElementById("voltageValue");
            if (voltageEl) {
              voltageEl.textContent = (
                selectedNeuron.userData.volt || 0
              ).toFixed(3);
            }
          }
        }

        // Network topology
        function createNetworkTopology() {
          // Clear existing
          neurons.forEach((n) => scene.remove(n));
          glows.forEach((g) => scene.remove(g));
          neurons.length = 0;
          glows.length = 0;

          const radius = 35;
          const N_EXC = 40,
            N_INH = 10;

          // Create excitatory neurons
          for (let i = 0; i < N_EXC; i++) {
            const clusterId = Math.floor(i / (N_EXC / 4));
            const clusterColor = CLUSTER_COLORS[clusterId];

            const angleY =
              (i / (N_EXC / 4)) * Math.PI * 2 + clusterId * Math.PI * 0.5;
            const angleX = (Math.floor(i / (N_EXC / 3)) / 3) * Math.PI;
            const clusterRadius = radius + (Math.random() - 0.5) * 15;

            const position = new THREE.Vector3(
              Math.sin(angleX) * Math.cos(angleY) * clusterRadius,
              Math.cos(angleX) * clusterRadius * 0.7,
              Math.sin(angleX) * Math.sin(angleY) * clusterRadius
            );

            const geometry = new THREE.SphereGeometry(1.2, 24, 24);
            const material = new THREE.MeshStandardMaterial({
              color: clusterColor.primary,
              emissive: clusterColor.primary.clone().multiplyScalar(0.4),
              roughness: 0.3,
              metalness: 0.8,
              transparent: true,
              opacity: 0.9,
            });

            const neuron = new THREE.Mesh(geometry, material);
            neuron.position.copy(position);
            neuron.userData = {
              id: i,
              cluster: clusterId,
              pulse: 0,
              volt: 0,
              type: "excitatory",
              originalColor: clusterColor.primary.clone(),
              glowColor: clusterColor.glow.clone(),
            };
            scene.add(neuron);
            neurons.push(neuron);

            // Glow effect
            const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: clusterColor.glow,
              transparent: true,
              opacity: 0.15,
              blending: THREE.AdditiveBlending,
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(position);
            scene.add(glow);
            glows.push(glow);
          }

          // Create inhibitory neurons
          for (let i = 0; i < N_INH; i++) {
            const angle = (i / N_INH) * Math.PI * 2;
            const height = (Math.random() - 0.5) * 40;
            const r = radius * 1.3;

            const position = new THREE.Vector3(
              Math.cos(angle) * r,
              height,
              Math.sin(angle) * r
            );

            const geometry = new THREE.SphereGeometry(1.0, 20, 20);
            const material = new THREE.MeshStandardMaterial({
              color: CLUSTER_COLORS[4].primary,
              emissive: CLUSTER_COLORS[4].primary.clone().multiplyScalar(0.4),
              roughness: 0.3,
              metalness: 0.8,
              transparent: true,
              opacity: 0.9,
            });

            const neuron = new THREE.Mesh(geometry, material);
            neuron.position.copy(position);
            neuron.userData = {
              id: i + N_EXC,
              cluster: 4,
              pulse: 0,
              volt: 0,
              type: "inhibitory",
              originalColor: CLUSTER_COLORS[4].primary.clone(),
              glowColor: CLUSTER_COLORS[4].glow.clone(),
            };
            scene.add(neuron);
            neurons.push(neuron);

            const glowGeometry = new THREE.SphereGeometry(2.0, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: CLUSTER_COLORS[4].glow,
              transparent: true,
              opacity: 0.15,
              blending: THREE.AdditiveBlending,
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(position);
            scene.add(glow);
            glows.push(glow);
          }

          createConnectionNetwork();
          console.log(`Created network: ${neurons.length} neurons`);
        }

        function createConnectionNetwork() {
          const positions = [];
          const colors = [];
          const connectionData = [];

          for (let i = 0; i < neurons.length; i++) {
            for (let j = 0; j < neurons.length; j++) {
              if (i !== j) {
                const prob =
                  neurons[i].userData.cluster === neurons[j].userData.cluster
                    ? 0.6
                    : 0.3;

                if (Math.random() < prob) {
                  const fromPos = neurons[i].position;
                  const toPos = neurons[j].position;

                  positions.push(fromPos.x, fromPos.y, fromPos.z);
                  positions.push(toPos.x, toPos.y, toPos.z);

                  const fromCluster = neurons[i].userData.cluster;
                  const color = CLUSTER_COLORS[fromCluster].primary
                    .clone()
                    .multiplyScalar(0.4);

                  colors.push(color.r, color.g, color.b);
                  colors.push(color.r, color.g, color.b);

                  connectionData.push({ from: i, to: j, cluster: fromCluster });
                }
              }
            }
          }

          connGeom = new THREE.BufferGeometry();
          connGeom.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(positions, 3)
          );
          connGeom.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
          );
          col = connGeom.getAttribute("color");

          const lineMat = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
          });

          lines = new THREE.LineSegments(connGeom, lineMat);
          scene.add(lines);

          connections = connectionData;
          console.log(`Created ${connections.length} connections`);
        }

        // FIXED: Camera control functions
        function setupCameraControls() {
          const canvas = renderer.domElement;

          canvas.addEventListener("mousedown", (e) => {
            if (e.button === 0) {
              isDragging = true;
            } else if (e.button === 2) {
              isPanning = true;
              e.preventDefault();
            }
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
          });

          canvas.addEventListener("mousemove", (e) => {
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;

            if (isDragging) {
              cameraTheta -= deltaX * 0.01;
              cameraPhi += deltaY * 0.01;
              cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
              updateCameraPosition();
            } else if (isPanning) {
              const panSpeed = cameraDistance * 0.0008;
              const right = new THREE.Vector3(
                -Math.cos(cameraTheta),
                0,
                Math.sin(cameraTheta)
              );
              const up = new THREE.Vector3(0, 1, 0);

              cameraTarget.add(right.multiplyScalar(-deltaX * panSpeed));
              cameraTarget.add(up.multiplyScalar(deltaY * panSpeed));
              updateCameraPosition();
            }

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
          });

          canvas.addEventListener("mouseup", () => {
            isDragging = false;
            isPanning = false;
          });

          canvas.addEventListener("contextmenu", (e) => e.preventDefault());

          canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            const zoomSpeed = cameraDistance * 0.1;
            cameraDistance += e.deltaY * zoomSpeed * 0.001;
            cameraDistance = Math.max(10, Math.min(500, cameraDistance));
            updateCameraPosition();
            updateZoomIndicator();
          });

          canvas.addEventListener("click", (e) => {
            if (isDragging) return;

            const mouse = new THREE.Vector2();
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(neurons);
            if (intersects.length > 0) {
              selectNeuron(intersects[0].object);
            } else {
              deselectNeuron();
            }
          });

          canvas.addEventListener("dblclick", (e) => {
            const mouse = new THREE.Vector2();
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(neurons);
            if (intersects.length > 0) {
              focusOnNeuron(intersects[0].object);
            }
          });

          document.addEventListener("keydown", (e) => {
            switch (e.code) {
              case "Space":
                e.preventDefault();
                resetCameraView();
                break;
              case "KeyF":
                if (selectedNeuron) focusOnNeuron(selectedNeuron);
                break;
              case "Escape":
                deselectNeuron();
                break;
            }
          });
        }

        function updateCameraPosition() {
          const x =
            cameraTarget.x +
            cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
          const y = cameraTarget.y + cameraDistance * Math.cos(cameraPhi);
          const z =
            cameraTarget.z +
            cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);

          camera.position.set(x, y, z);
          camera.lookAt(cameraTarget);
        }

        function updateZoomIndicator() {
          const zoomElement = document.getElementById("zoomValue");
          if (zoomElement) {
            const zoomPercent = Math.round(
              ((200 - cameraDistance) / 190) * 100
            );
            zoomElement.textContent = Math.max(0, zoomPercent) + "%";
          }
        }

        function resetCameraView() {
          cameraTarget.set(0, 0, 0);
          cameraDistance = 120;
          cameraTheta = 0;
          cameraPhi = Math.PI / 2;
          updateCameraPosition();
          updateZoomIndicator();
        }

        function selectNeuron(neuron) {
          if (selectedNeuron) {
            selectedNeuron.material.emissive.copy(
              selectedNeuron.userData.originalColor.clone().multiplyScalar(0.4)
            );
          }

          selectedNeuron = neuron;
          selected = neuron.userData.id;

          neuron.material.emissive.copy(
            new THREE.Color(0xff00d6).multiplyScalar(0.8)
          );

          updateNeuronInfo(neuron);
          const neuronInfoElement = document.getElementById("neuronInfo");
          if (neuronInfoElement) {
            neuronInfoElement.style.display = "block";
          }
        }

        function deselectNeuron() {
          if (selectedNeuron) {
            selectedNeuron.material.emissive.copy(
              selectedNeuron.userData.originalColor.clone().multiplyScalar(0.4)
            );
            selectedNeuron = null;
            selected = null;
          }
          const neuronInfoElement = document.getElementById("neuronInfo");
          if (neuronInfoElement) {
            neuronInfoElement.style.display = "none";
          }
        }

        function focusOnNeuron(neuron) {
          selectNeuron(neuron);

          const targetPos = neuron.position.clone();
          const duration = 1000;
          const startTarget = cameraTarget.clone();
          const startDistance = cameraDistance;
          const endDistance = 30;
          const startTime = Date.now();

          function animateCamera() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            cameraTarget.lerpVectors(startTarget, targetPos, eased);
            cameraDistance =
              startDistance + (endDistance - startDistance) * eased;

            updateCameraPosition();
            updateZoomIndicator();

            if (progress < 1) {
              requestAnimationFrame(animateCamera);
            }
          }
          animateCamera();
        }

        function updateNeuronInfo(neuron) {
          const userData = neuron.userData;
          const neuronId = userData.id;

          let connectionsIn = 0;
          let connectionsOut = 0;
          connections.forEach((conn) => {
            if (conn.to === neuronId) connectionsIn++;
            if (conn.from === neuronId) connectionsOut++;
          });

          const history = neuronActivityHistory.get(neuronId) || [];
          const recentSpikes = history.filter(
            (time) => Date.now() - time < 5000
          ).length;
          const activityRate = (recentSpikes / 5).toFixed(1);

          const setElementText = (id, text) => {
            const el = document.getElementById(id);
            if (el) el.textContent = text;
          };

          setElementText("neuronId", neuronId);
          setElementText("neuronType", userData.type);
          setElementText("neuronCluster", userData.cluster);
          setElementText("neuronVoltage", (userData.volt || 0).toFixed(3));
          setElementText(
            "neuronLastSpike",
            history.length > 0
              ? `${((Date.now() - history[history.length - 1]) / 1000).toFixed(
                  1
                )}s ago`
              : "Never"
          );
          setElementText("neuronConnIn", connectionsIn);
          setElementText("neuronConnOut", connectionsOut);
          setElementText("neuronActivity", activityRate + " Hz");
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const clusterActivity = [0, 0, 0, 0, 0];

          for (let i = 0; i < neurons.length; i++) {
            const n = neurons[i],
              g = glows[i],
              u = n.userData;

            // Always visible base color with voltage modulation
            const voltage = Math.max(0, Math.min(1, u.volt || 0));
            const baseColor = u.originalColor.clone();
            baseColor.lerp(u.glowColor, voltage * 0.4);
            n.material.color.copy(baseColor);

            if (u.pulse > 0) {
              u.pulse *= 0.85;
              const intensity = u.pulse / 1.2;

              clusterActivity[u.cluster] += intensity;

              if (n === selectedNeuron) {
                n.material.emissive.copy(
                  new THREE.Color(0xff00d6).multiplyScalar(
                    0.8 + intensity * 0.5
                  )
                );
              } else {
                const glowColor = u.glowColor
                  .clone()
                  .multiplyScalar(intensity * 2);
                n.material.emissive.copy(glowColor);
              }

              n.scale.setScalar(1.0 + intensity * 0.4);
              g.material.opacity = 0.2 + intensity * 0.6;
              g.scale.setScalar(1.0 + intensity * 3.0);
              g.material.color.copy(u.glowColor);
            } else {
              if (n === selectedNeuron) {
                n.material.emissive.copy(
                  new THREE.Color(0xff00d6).multiplyScalar(0.6)
                );
              } else {
                n.material.emissive.copy(
                  u.originalColor.clone().multiplyScalar(0.4)
                );
              }
              n.scale.setScalar(1.0);
              g.material.opacity = 0.15;
              g.scale.setScalar(1.0);
            }
          }

          // Update connection colors
          if (connGeom && col && connections.length > 0) {
            for (let i = 0; i < connections.length; i++) {
              const conn = connections[i];
              const baseIdx = i * 6;

              if (baseIdx + 5 < col.array.length) {
                const clusterColor = CLUSTER_COLORS[conn.cluster].primary;
                const activity = clusterActivity[conn.cluster];

                let intensity = 0.4;
                if (
                  selectedNeuron &&
                  (conn.from === selectedNeuron.userData.id ||
                    conn.to === selectedNeuron.userData.id)
                ) {
                  intensity = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                }

                const activityBoost = Math.min(activity * 0.8, 1.0);
                const totalIntensity = intensity + activityBoost;

                col.array[baseIdx] = clusterColor.r * totalIntensity;
                col.array[baseIdx + 1] = clusterColor.g * totalIntensity;
                col.array[baseIdx + 2] = clusterColor.b * totalIntensity;
                col.array[baseIdx + 3] = clusterColor.r * totalIntensity;
                col.array[baseIdx + 4] = clusterColor.g * totalIntensity;
                col.array[baseIdx + 5] = clusterColor.b * totalIntensity;
              }
            }
            col.needsUpdate = true;
          }

          drawTrace();
          renderer.render(scene, camera);
        }

        // Message handling
        function handleMessage(e) {
          const d = JSON.parse(e.data);

          if (d.volt) {
            for (const k in d.volt) {
              const i = +k;
              if (neurons[i]) {
                neurons[i].userData.volt = d.volt[k];

                // Update voltage display if this neuron is selected
                if (selectedNeuron && selectedNeuron.userData.id === i) {
                  const voltageEl = document.getElementById("neuronVoltage");
                  if (voltageEl) voltageEl.textContent = d.volt[k].toFixed(3);
                }

                if (selected === i) {
                  traceBuf.push(d.volt[k]);
                  if (traceBuf.length > 200) traceBuf.shift();
                }
              }
            }
          }

          if (d.spikes) {
            const clusterSpikes = {};
            const currentTime = Date.now();

            d.spikes.forEach((spike) => {
              const i = spike.i;
              if (neurons[i]) {
                const neuron = neurons[i];
                const cluster = neuron.userData.cluster;

                // Track spike in history
                if (!neuronActivityHistory.has(i)) {
                  neuronActivityHistory.set(i, []);
                }
                const history = neuronActivityHistory.get(i);
                history.push(currentTime);

                // Keep only recent spikes (last 30 seconds)
                while (history.length > 0 && currentTime - history[0] > 30000) {
                  history.shift();
                }

                neuron.userData.pulse = 1.2;

                // Update selected neuron info if needed
                if (selectedNeuron && selectedNeuron.userData.id === i) {
                  updateNeuronInfo(selectedNeuron);
                }

                if (!clusterSpikes[cluster]) clusterSpikes[cluster] = [];
                clusterSpikes[cluster].push(neuron);
              }
            });

            // CLUSTER BURST EFFECTS
            Object.keys(clusterSpikes).forEach((clusterId) => {
              const spikes = clusterSpikes[clusterId];
              if (spikes.length > 1) {
                neurons.forEach((n) => {
                  if (n.userData.cluster == clusterId) {
                    n.userData.pulse = Math.max(n.userData.pulse, 1.5);
                  }
                });
              }
            });
          }
        }

        // FIXED: Button controls
        const btn = document.getElementById("play");
        const rng = document.getElementById("speed");

        if (btn) {
          btn.onclick = () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            const isCurrentlyPaused = btn.classList.contains("on");

            if (isCurrentlyPaused) {
              btn.classList.remove("on");
              btn.textContent = "Play";
              ws.send(JSON.stringify({ cmd: "pause" }));
            } else {
              btn.classList.add("on");
              btn.textContent = "Pause";
              ws.send(JSON.stringify({ cmd: "play" }));
            }
          };
        }

        if (rng) {
          rng.oninput = () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const speed = parseInt(rng.value, 10);
            const dt_ms = Math.max(5, 200 - speed);
            ws.send(JSON.stringify({ cmd: "speed", dt_ms: dt_ms }));
          };
        }

        // FIXED: Control sliders
        const inputSlider = document.getElementById("inputCurrent");
        if (inputSlider) {
          inputSlider.addEventListener("input", () => {
            const v = parseFloat(inputSlider.value);
            const label = document.getElementById("inputValue");
            if (label) label.textContent = v.toFixed(1);
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ cmd: "setInput", value: v }));
            }
          });
        }

        const synapseSlider = document.getElementById("synapseWeight");
        if (synapseSlider) {
          synapseSlider.addEventListener("input", () => {
            const v = parseFloat(synapseSlider.value);
            const label = document.getElementById("weightValue");
            if (label) label.textContent = v.toFixed(2);
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ cmd: "setWeight", value: v }));
            }
          });
        }

        const probSlider = document.getElementById("connectionProb");
        if (probSlider) {
          probSlider.addEventListener("input", () => {
            const v = parseFloat(probSlider.value);
            const label = document.getElementById("probValue");
            if (label) label.textContent = v.toFixed(3);
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ cmd: "setConnectionProb", value: v }));
            }
          });
        }

        const sizeSlider = document.getElementById("networkSize");
        if (sizeSlider) {
          sizeSlider.addEventListener("input", () => {
            const v = parseInt(sizeSlider.value, 10);
            const label = document.getElementById("sizeValue");
            if (label) label.textContent = v;
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ cmd: "setNetworkSize", value: v }));
              ws.send(JSON.stringify({ cmd: "reset" }));
            }
          });
        }

        const resetBtn = document.getElementById("resetNetwork");
        if (resetBtn) {
          resetBtn.addEventListener("click", () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ cmd: "reset" }));
            }
          });
        }

        const showWeightsBtn = document.getElementById("showWeights");
        if (showWeightsBtn) {
          showWeightsBtn.addEventListener("click", () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ cmd: "toggleWeights" }));
            }
          });
        }

        const injectBtn = document.getElementById("injectPattern");
        if (injectBtn) {
          injectBtn.addEventListener("click", () => {
            if (ws && ws.readyState === WebSocket.OPEN)
              ws.send(JSON.stringify({ cmd: "injectPattern" }));
          });
        }

        const testBtn = document.getElementById("testMemory");
        if (testBtn) {
          testBtn.addEventListener("click", () => {
            if (ws && ws.readyState === WebSocket.OPEN)
              ws.send(JSON.stringify({ cmd: "testMemory" }));
          });
        }

        // Lesson helper functions
        function updateLessonContent() {
          const box = document.getElementById("lessonContent");
          if (!box) return;
          const lesson = lessonContent[currentLesson];
          box.innerHTML = `<div class="lesson"><strong>Lesson ${currentLesson}: ${
            lesson ? lesson.title : "N/A"
          }</strong><br>${lesson ? lesson.content : ""}</div>`;
        }

        function updateLessonControls() {
          const pc = document.getElementById("patternControls");
          if (pc) pc.style.display = currentLesson === 4 ? "block" : "none";
        }

        function updateNavigationButtons() {
          const selEl = document.getElementById("lessonSelect");
          if (selEl) selEl.value = currentLesson;
          const prevBtn = document.getElementById("prevLesson");
          const nextBtn = document.getElementById("nextLesson");
          if (prevBtn) prevBtn.disabled = currentLesson === 1;
          if (nextBtn) nextBtn.disabled = currentLesson === 4;
        }

        // Wire up lesson controls
        document.querySelectorAll(".toggle").forEach((btn) => {
          btn.addEventListener("click", () => {
            document
              .querySelectorAll(".toggle")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");
            currentLesson = parseInt(btn.id.replace("lesson", "")) || 1;
            updateLessonContent();
            updateLessonControls();
            updateNavigationButtons();
          });
        });

        // Lesson modal with full content
        function openLessonModal() {
          const modal = document.getElementById("lessonModal");
          const fallback = document.getElementById("lessonFallback");
          if (!modal || !fallback) return;

          modal.style.display = "block";
          fallback.style.display = "block";
          document.getElementById("lessonFrame").style.display = "none";

          const fullContent = {
            1: `<h1>Lesson 1: Basic Spike Dynamics</h1><p>Neural networks are built from individual neurons that integrate electrical signals and fire action potentials when threshold is reached. Use the Input Current slider to experiment with different firing patterns.</p>`,
            2: `<h1>Lesson 2: Synaptic Transmission</h1><p>Neurons communicate through synaptic connections. Adjust Synaptic Weight and Connection Probability to see how network connectivity affects information flow.</p>`,
            3: `<h1>Lesson 3: Network Plasticity</h1><p>Neural networks adapt through synaptic plasticity - the strengthening and weakening of connections based on activity patterns. This is the basis of learning and memory.</p>`,
            4: `<h1>Lesson 4: Pattern Recognition</h1><p>Neural networks can store and recall patterns through associative memory. Use Inject Pattern and Test Memory to experiment with pattern storage and retrieval.</p>`,
          };

          fallback.innerHTML =
            fullContent[currentLesson] ||
            `<p>Lesson ${currentLesson} not available.</p>`;
        }

        // Hook modal controls
        const viewBtn = document.getElementById("viewLesson");
        if (viewBtn) viewBtn.addEventListener("click", openLessonModal);

        const closeModal = document.getElementById("closeModal");
        if (closeModal)
          closeModal.addEventListener("click", () => {
            const modal = document.getElementById("lessonModal");
            if (modal) modal.style.display = "none";
          });

        const modal = document.getElementById("lessonModal");
        if (modal)
          modal.addEventListener("click", (e) => {
            if (e.target === modal) modal.style.display = "none";
          });

        // Initialize
        setupCameraControls();
        updateZoomIndicator();
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
        createNetworkTopology();
        connectWS();
        animate();

        // Handle window resize
        addEventListener("resize", () => {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
        });
      }

      // Start the application
      if (window.THREE) {
        initApp();
      } else {
        setTimeout(initApp, 100);
      }
    </script>
  </body>
</html>
