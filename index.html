<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>SNN Visualizer — SYNTHETIC-2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #0a0c12;
        --panel: #12151c;
        --text: #c4d1e0;
        --muted: #6b7280;
        --edge: #1e293b;
        --edgeHot: #3b82f6;
        --node: #60a5fa;
        --hot: #f59e0b;
        --pulse: #ef4444;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font: 14px/1.5 Inter, system-ui, Helvetica, Arial;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #overlay {
        pointer-events: none;
        position: fixed;
        inset: 0;
        background: radial-gradient(
            1400px 900px at 30% 0%,
            #1e293b22,
            transparent 70%
          ),
          radial-gradient(1000px 600px at 80% 100%, #1e1b4b22, transparent 60%);
      }
      #hud {
        position: fixed;
        left: 20px;
        top: 20px;
        display: flex;
        gap: 14px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 12px 16px;
        border-radius: 16px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }
      .btn {
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        background: rgba(12, 8, 18, 0.9);
        color: #f3f2ff;
        cursor: pointer;
        padding: 10px 14px;
        transition: all 0.12s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      }
      .btn.on {
        background: #ff00d6;
        color: #06010a;
        border-color: rgba(255, 0, 214, 0.35);
        box-shadow: 0 0 18px rgba(255, 0, 214, 0.12);
      }
      .range {
        accent-color: #ff00d6;
      }
      #panel {
        position: fixed;
        right: 20px;
        top: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      }
      #panel h4 {
        margin: 0 0 8px;
        font-weight: 600;
        color: #f1f5f9;
        font-size: 15px;
      }
      #trace {
        width: 100%;
        height: 150px;
        background: #0f172a;
        border-radius: 12px;
        border: 1px solid #1e293b;
      }
      #err {
        position: fixed;
        left: 20px;
        bottom: 20px;
        background: #dc2626;
        color: #fff;
        padding: 10px 14px;
        border-radius: 12px;
        display: none;
      }
      #controls {
        position: fixed;
        left: 20px;
        bottom: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        max-height: 300px;
        overflow-y: auto;
      }
      .control-group {
        margin-bottom: 12px;
      }
      .control-group label {
        display: block;
        margin-bottom: 4px;
        font-size: 13px;
        color: #94a3b8;
      }
      .control-group input[type="range"] {
        width: 100%;
        accent-color: #3b82f6;
      }
      .toggle {
        background: #1e293b;
        border: 1px solid #334155;
        padding: 6px 12px;
        border-radius: 8px;
        cursor: pointer;
        display: inline-block;
        margin: 2px;
      }
      .toggle.active {
        background: #1e40af;
        color: #fff;
      }
      #info {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 320px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        font-size: 13px;
        line-height: 1.6;
        z-index: 100; /* Ensure it's on top */
      }
      .lesson {
        background: #0f172a;
        padding: 12px;
        border-radius: 8px;
        margin: 8px 0;
        border-left: 3px solid #3b82f6;
      }

      /* Panel borders and consistent dark panels */
      #hud,
      #panel,
      #controls,
      #info,
      #lessonPanel,
      #navControls,
      #neuronInfo,
      #zoomLevel,
      #lessonModal {
        position: fixed;
        z-index: 10; /* Ensure all UI is on top */
      }

      #lessonModal {
        z-index: 20; /* Modal should be on top of everything */
      }

      #three-canvas {
        position: fixed;
        inset: 0;
        z-index: 0; /* Place canvas behind all UI */
        background: #c00; /* Red background for debug */
      }

      /* Original styles for panels */
      #hud {
        left: 20px;
        top: 20px;
        display: flex;
        gap: 14px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 12px 16px;
        border-radius: 16px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }
      #panel {
        right: 20px;
        top: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      }
      #controls {
        left: 20px;
        bottom: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        max-height: 300px;
        overflow-y: auto;
      }
      #info {
        right: 20px;
        bottom: 20px;
        width: 320px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        font-size: 13px;
        line-height: 1.6;
        z-index: 100; /* Ensure it's on top */
      }
      #lessonPanel {
        left: 20px;
        top: 80px;
        display: flex;
        gap: 12px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 10px 16px;
        border-radius: 12px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }
      #navControls {
        right: 20px;
        top: 200px;
        background: rgba(12, 8, 18, 0.9);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 12px;
        padding: 12px;
        color: #f3f2ff;
        font-size: 11px;
        line-height: 1.4;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        max-width: 180px;
      }
      #neuronInfo {
        left: 20px;
        top: 300px;
        width: 280px;
        background: rgba(12, 8, 18, 0.95);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 12px;
        padding: 14px;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        display: none;
        z-index: 100;
      }
      #zoomLevel {
        right: 20px;
        bottom: 120px;
        background: rgba(12, 8, 18, 0.8);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 11px;
        color: #94a3b8;
        z-index: 100;
      }

      /* Common styles for lesson content */
      #lessonFullContent {
        color: #e6e9ef;
        background: transparent;
      }
      #lessonFullContent h1,
      #lessonFullContent h2,
      #lessonFullContent h3,
      #lessonFullContent strong {
        background: transparent !important;
        color: #ff9bf0 !important; /* neon magenta title color */
        margin: 0 0 8px 0;
      }
      /* Small lesson card title emphasis */
      .lesson strong {
        color: #ff9bf0;
      }

      /* Lesson iframe (full lesson) */
      #lessonModal > div {
        overflow: hidden;
      }
      #lessonFrame {
        width: 100%;
        height: 60vh;
        border: none;
        border-radius: 10px;
        background: transparent;
        display: block;
      }
      #lessonFallback {
        padding: 12px 0;
        color: #cbd5e1;
        line-height: 1.6;
      }

      /* Navigation controls HUD */
      #navControls {
        position: fixed;
        right: 20px;
        top: 200px;
        background: rgba(12, 8, 18, 0.9);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 12px;
        padding: 12px;
        color: #f3f2ff;
        font-size: 11px;
        line-height: 1.4;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        max-width: 180px;
      }

      #navControls h5 {
        margin: 0 0 8px 0;
        color: #ff9bf0;
        font-size: 12px;
        font-weight: 600;
      }

      .nav-tip {
        margin: 4px 0;
        color: #94a3b8;
      }
      /* Selected neuron info panel */
      #neuronInfo {
        position: fixed;
        left: 20px;
        top: 300px;
        width: 280px;
        background: rgba(12, 8, 18, 0.95);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 12px;
        padding: 14px;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        display: none;
        z-index: 100;
      }

      #neuronInfo h5 {
        margin: 0 0 8px 0;
        color: #ff9bf0;
        font-size: 13px;
        font-weight: 600;
      }

      .neuron-detail {
        margin: 6px 0;
        font-size: 12px;
        color: #e6f7ff;
      }

      .neuron-detail strong {
        color: #00f0ff;
      }

      /* Zoom level indicator */
      #zoomLevel {
        position: fixed;
        right: 20px;
        bottom: 120px;
        background: rgba(12, 8, 18, 0.8);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 11px;
        color: #94a3b8;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.min.js"></script>
    <canvas
      id="three-canvas"
      style="
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
        background: #c00;
      "
    ></canvas>
    <div id="overlay"></div>
    <div id="hud">
      <div style="font-weight: 600; color: #f1f5f9">SNN • Neural Network</div>
      <button id="play" class="btn on">Pause</button>
      <label style="color: #94a3b8"
        >Speed
        <input
          id="speed"
          class="range"
          type="range"
          min="10"
          max="150"
          value="50"
      /></label>
    </div>

    <div id="panel">
      <h4 id="sel">Select Neuron</h4>
      <div style="margin-bottom: 8px; font-size: 12px; color: #94a3b8">
        Voltage:
        <span id="voltageValue" style="color: #f223e0; font-weight: bold"
          >--</span
        >
        <span style="margin-left: 10px"
          >Threshold: <span style="color: #60a5fa">1.0</span></span
        >
      </div>
      <canvas id="trace" width="260" height="150"></canvas>
    </div>

    <!-- Re-added lesson panel (restore missing settings UI) -->
    <div
      id="lessonPanel"
      style="
        position: fixed;
        left: 20px;
        top: 80px;
        display: flex;
        gap: 12px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 10px 16px;
        border-radius: 12px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      "
    >
      <label for="lessonSelect" style="color: #94a3b8; font-weight: 500"
        >Lesson:</label
      >
      <select id="lessonSelect">
        <option value="1">Lesson 1: Basic Spike Dynamics</option>
        <option value="2">Lesson 2: Synaptic Transmission</option>
        <option value="3">Lesson 3: Network Plasticity</option>
        <option value="4">Lesson 4: Pattern Recognition</option>
      </select>
      <div style="display: flex; gap: 8px">
        <button
          id="prevLesson"
          class="btn"
          style="padding: 6px 10px; font-size: 12px"
        >
          ← Prev
        </button>
        <button
          id="nextLesson"
          class="btn"
          style="padding: 6px 10px; font-size: 12px"
        >
          Next →
        </button>
        <button
          id="viewLesson"
          class="btn"
          style="
            padding: 6px 10px;
            font-size: 12px;
            background: #f223e0;
            color: #fff;
          "
        >
          📖 View Full
        </button>
      </div>
    </div>

    <div id="controls">
      <h4 style="margin: 0 0 12px; color: #f1f5f9">Learning Controls</h4>
      <div class="control-group">
        <label>Lesson Mode:</label>
        <div style="display: flex; gap: 6px; flex-wrap: wrap">
          <div class="toggle active" id="lesson1">Basic Spikes</div>
          <div class="toggle" id="lesson2">Synapses</div>
          <div class="toggle" id="lesson3">Plasticity</div>
          <div class="toggle" id="lesson4">Patterns</div>
        </div>
      </div>

      <div class="control-group">
        <label for="inputCurrent"
          >Input Current: <span id="inputValue">0.5</span></label
        >
        <input
          type="range"
          id="inputCurrent"
          min="0"
          max="2"
          step="0.1"
          value="0.5"
        />
      </div>

      <div class="control-group">
        <label for="synapseWeight"
          >Synaptic Weight: <span id="weightValue">0.2</span></label
        >
        <input
          type="range"
          id="synapseWeight"
          min="0"
          max="1"
          step="0.05"
          value="0.2"
        />
      </div>

      <div class="control-group">
        <label for="networkSize"
          >Network Size: <span id="sizeValue">50</span></label
        >
        <input
          type="range"
          id="networkSize"
          min="10"
          max="100"
          step="5"
          value="50"
        />
      </div>

      <div class="control-group">
        <label for="connectionProb"
          >Connection Probability: <span id="probValue">0.045</span></label
        >
        <input
          type="range"
          id="connectionProb"
          min="0"
          max="0.2"
          step="0.005"
          value="0.045"
        />
      </div>

      <button id="resetNetwork" class="btn">Reset Network</button>
      <button id="showWeights" class="btn">Show Weights</button>

      <div class="control-group" id="patternControls" style="display: none">
        <button
          id="injectPattern"
          class="btn"
          style="width: 100%; margin-bottom: 8px"
        >
          Inject Pattern
        </button>
        <button id="testMemory" class="btn" style="width: 100%">
          Test Memory
        </button>
      </div>
    </div>
    <div
      id="lessonModal"
      style="
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(4px);
        z-index: 1000;
        overflow-y: auto;
      "
    >
      <div
        style="
          max-width: 800px;
          margin: 40px auto;
          background: #12151c;
          border: 1px solid #334155;
          border-radius: 16px;
          padding: 18px 20px;
          position: relative;
        "
      >
        <button
          id="closeModal"
          style="
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 24px;
            cursor: pointer;
          "
        >
          ×
        </button>
        <iframe
          id="lessonFrame"
          src=""
          title="Lesson content"
          sandbox="allow-same-origin allow-scripts allow-forms"
        ></iframe>
        <div id="lessonFallback" style="display: none"></div>
      </div>
    </div>

    <!-- Add navigation help panel -->
    <div id="navControls">
      <h5>🎮 Navigation</h5>
      <div class="nav-tip"><strong>Mouse Drag:</strong> Rotate view</div>
      <div class="nav-tip"><strong>Mouse Wheel:</strong> Zoom in/out</div>
      <div class="nav-tip"><strong>Right Click:</strong> Pan camera</div>
      <div class="nav-tip"><strong>Click Neuron:</strong> Inspect details</div>
      <div class="nav-tip"><strong>Double Click:</strong> Focus on neuron</div>
      <div class="nav-tip"><strong>Space:</strong> Reset view</div>
    </div>

    <!-- Selected neuron detailed info -->
    <div id="neuronInfo">
      <h5>🔍 Neuron Inspector</h5>
      <div class="neuron-detail">
        <strong>ID:</strong> <span id="neuronId">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Type:</strong> <span id="neuronType">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Cluster:</strong> <span id="neuronCluster">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Voltage:</strong> <span id="neuronVoltage">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Last Spike:</strong> <span id="neuronLastSpike">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Connections In:</strong> <span id="neuronConnIn">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Connections Out:</strong> <span id="neuronConnOut">--</span>
      </div>
      <div class="neuron-detail">
        <strong>Activity Rate:</strong> <span id="neuronActivity">--</span>
      </div>
    </div>

    <!-- Zoom level indicator -->
    <div id="zoomLevel">Zoom: <span id="zoomValue">100%</span></div>

    <div id="info">
      <h4 style="margin: 0 0 8px; color: #f1f5f9">Learning Guide</h4>
      <div id="lessonContent">
        <div class="lesson">
          <strong>Lesson 1: Basic Spikes</strong><br />
          Each neuron accumulates voltage over time. When it reaches threshold
          (v=1), it fires a spike and resets to 0.
        </div>
      </div>
    </div>
    <div id="err"></div>

    <script>
      // WebSocket connection
      let ws;
      function connectWS() {
        try {
          ws = new WebSocket("ws://localhost:8766");
          ws.onopen = () => {
            console.log("Connected to SNN server");
            const errEl = document.getElementById("err");
            if (errEl) errEl.style.display = "none";
          };
          ws.onerror = () => {
            const errEl = document.getElementById("err");
            if (errEl) {
              errEl.textContent =
                "Connection failed. Make sure server.py is running.";
              errEl.style.display = "block";
            }
          };
          ws.onclose = () => setTimeout(connectWS, 2000);
          ws.onmessage = handleMessage;
        } catch (error) {
          const errEl = document.getElementById("err");
          if (errEl) {
            errEl.textContent = "Failed to connect to server";
            errEl.style.display = "block";
          }
        }
      }

      // Constants
      const NUM = 50;

      // Initialize the neural network when page loads
      function initNeuralNetwork() {
        console.log("Initializing Neural Network...");

        // Check if Three.js is loaded
        if (typeof THREE === "undefined") {
          console.log("Waiting for Three.js to load...");
          setTimeout(initNeuralNetwork, 100);
          return;
        }

        console.log("Three.js loaded! Creating 3D neural network...");

        // Initialize CLUSTER_COLORS after Three.js is loaded
        const CLUSTER_COLORS = [
          {
            primary: new THREE.Color(0.0, 0.8, 1.0),
            glow: new THREE.Color(0.3, 0.9, 1.0),
          },
          {
            primary: new THREE.Color(1.0, 0.2, 0.8),
            glow: new THREE.Color(1.0, 0.5, 0.9),
          },
          {
            primary: new THREE.Color(0.9, 1.0, 0.0),
            glow: new THREE.Color(1.0, 1.0, 0.4),
          },
          {
            primary: new THREE.Color(1.0, 0.5, 0.0),
            glow: new THREE.Color(1.0, 0.7, 0.3),
          },
          {
            primary: new THREE.Color(1.0, 0.0, 0.4),
            glow: new THREE.Color(1.0, 0.3, 0.6),
          },
        ];

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0c12); // Dark blue background

        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 80);
        camera.lookAt(0, 0, 0);

        // Use the existing canvas instead of creating a new one
        const canvas = document.getElementById("three-canvas");
        let renderer;
        if (!canvas._renderer) {
          renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            powerPreference: "high-performance",
          });
          renderer.setClearColor(0xc00, 1); // Red background for debug
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          canvas._renderer = renderer;
        } else {
          renderer = canvas._renderer;
        }
        // Assign ID for CSS styling and place in body
        renderer.domElement.id = "three-canvas";
        document.body.appendChild(renderer.domElement);

        // Ensure the canvas resizes with the window
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Enhanced lighting for better visibility
        scene.add(new THREE.AmbientLight(0x404040, 0.6)); // Brighter ambient

        const keyLight = new THREE.PointLight(0x4080ff, 1.5, 200);
        keyLight.position.set(50, 50, 50);
        keyLight.castShadow = true;
        scene.add(keyLight);

        const fillLight = new THREE.PointLight(0xff6060, 1.0, 150);
        fillLight.position.set(-30, -30, 40);
        scene.add(fillLight);

        const backLight = new THREE.PointLight(0x60ff60, 0.8, 100);
        backLight.position.set(0, 0, -50);
        scene.add(backLight);

        // Add a large white test cube at the origin and rotate it
        const testGeometry = new THREE.BoxGeometry(10, 10, 10);
        const testMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const testCube = new THREE.Mesh(testGeometry, testMaterial);
        testCube.position.set(0, 0, 0);
        scene.add(testCube);
        console.log("Test cube added at origin");

        // Global variables
        const neurons = [],
          glows = [],
          connectionLabels = [];
        let connections = [];
        let connGeom, col, lines;
        let selected = null,
          traceBuf = [];
        let showWeights = false;

        // Camera controls
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let cameraDistance = 80;
        let cameraTheta = 0;
        let cameraPhi = Math.PI / 2;
        let isDragging = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let selectedNeuron = null;
        let neuronActivityHistory = new Map();
        let isRunning = true; // controls whether neurons update (Play/Pause)

        // Lesson content
        const lessonContent = {
          1: {
            title: "Basic Spike Dynamics",
            content:
              "Each neuron integrates input until threshold (v=1). When threshold is reached, it emits a spike and resets.",
          },
          2: {
            title: "Synaptic Transmission",
            content:
              "Synapses transmit spikes between neurons. Excitatory synapses increase voltage; inhibitory decrease it.",
          },
          3: {
            title: "Network Plasticity",
            content:
              "Plasticity mechanisms change synaptic strengths over time through Hebbian learning.",
          },
          4: {
            title: "Pattern Recognition",
            content:
              "Networks can store and recall patterns through strengthened connection pathways.",
          },
        };
        let currentLesson = 1;

        // Create the neural network
        function createNetworkTopology() {
          // Clear existing
          neurons.forEach((n) => scene.remove(n));
          glows.forEach((g) => scene.remove(g));
          neurons.length = 0;
          glows.length = 0;

          const radius = 25; // Smaller radius for better visibility
          // Use the network size slider value so UI can control topology
          const networkSizeSetting =
            parseInt(document.getElementById("networkSize")?.value) || 50;
          const N_EXC = Math.max(1, Math.round(networkSizeSetting * 0.8));
          const N_INH = Math.max(0, networkSizeSetting - N_EXC);

          // Create excitatory neurons in visible clusters
          for (let i = 0; i < N_EXC; i++) {
            const clusterId = Math.floor(i / (N_EXC / 4));
            const clusterColor = CLUSTER_COLORS[clusterId];

            // More spread out positioning for better visibility
            const angleY = (i / 10) * Math.PI * 2;
            const angleX = (Math.floor(i / 10) / 4) * Math.PI;
            const clusterRadius = radius + (Math.random() - 0.5) * 10;

            const position = new THREE.Vector3(
              Math.sin(angleX) * Math.cos(angleY) * clusterRadius,
              Math.cos(angleX) * clusterRadius * 0.8,
              Math.sin(angleX) * Math.sin(angleY) * clusterRadius
            );

            // Larger, more visible neurons
            const geometry = new THREE.SphereGeometry(3.0, 32, 32);
            const material = new THREE.MeshLambertMaterial({
              color: clusterColor.primary,
              emissive: clusterColor.primary.clone().multiplyScalar(0.5),
              transparent: true,
              opacity: 0.9,
            });

            const neuron = new THREE.Mesh(geometry, material);
            neuron.position.copy(position);
            neuron.userData = {
              id: i,
              cluster: clusterId,
              pulse: 0,
              volt: Math.random() * 0.5, // Random initial voltage
              type: "excitatory",
              originalColor: clusterColor.primary.clone(),
              glowColor: clusterColor.glow.clone(),
            };
            scene.add(neuron);
            neurons.push(neuron);

            // Brighter glow effect
            const glowGeometry = new THREE.SphereGeometry(4.0, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: clusterColor.glow,
              transparent: true,
              opacity: 0.2,
              blending: THREE.AdditiveBlending,
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(position);
            scene.add(glow);
            glows.push(glow);
          }

          // Create inhibitory neurons (red/pink)
          for (let i = 0; i < N_INH; i++) {
            const angle = (i / N_INH) * Math.PI * 2;
            const height = (Math.random() - 0.5) * 30;
            const r = radius * 1.4;

            const position = new THREE.Vector3(
              Math.cos(angle) * r,
              height,
              Math.sin(angle) * r
            );

            const geometry = new THREE.SphereGeometry(1.8, 24, 24);
            const material = new THREE.MeshStandardMaterial({
              color: CLUSTER_COLORS[4].primary,
              emissive: CLUSTER_COLORS[4].primary.clone().multiplyScalar(0.3),
              roughness: 0.4,
              metalness: 0.6,
              transparent: true,
              opacity: 0.9,
            });

            const neuron = new THREE.Mesh(geometry, material);
            neuron.position.copy(position);
            neuron.userData = {
              id: i + N_EXC,
              cluster: 4,
              pulse: 0,
              volt: Math.random() * 0.3,
              type: "inhibitory",
              originalColor: CLUSTER_COLORS[4].primary.clone(),
              glowColor: CLUSTER_COLORS[4].glow.clone(),
            };
            scene.add(neuron);
            neurons.push(neuron);

            const glowGeometry = new THREE.SphereGeometry(3.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: CLUSTER_COLORS[4].glow,
              transparent: true,
              opacity: 0.2,
              blending: THREE.AdditiveBlending,
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(position);
            scene.add(glow);
            glows.push(glow);
          }

          createConnectionNetwork();
          console.log(`Created network: ${neurons.length} neurons`);
        }

        function createConnectionNetwork() {
          const positions = [];
          const colors = [];
          const connectionData = [];

          for (let i = 0; i < neurons.length; i++) {
            for (let j = 0; j < neurons.length; j++) {
              if (i !== j) {
                const prob =
                  neurons[i].userData.cluster === neurons[j].userData.cluster
                    ? 0.6
                    : 0.3;

                if (Math.random() < prob) {
                  const fromPos = neurons[i].position;
                  const toPos = neurons[j].position;

                  positions.push(fromPos.x, fromPos.y, fromPos.z);
                  positions.push(toPos.x, toPos.y, toPos.z);

                  const fromCluster = neurons[i].userData.cluster;
                  const color = CLUSTER_COLORS[fromCluster].primary
                    .clone()
                    .multiplyScalar(0.4);

                  colors.push(color.r, color.g, color.b);
                  colors.push(color.r, color.g, color.b);

                  connectionData.push({ from: i, to: j, cluster: fromCluster });
                }
              }
            }
          }

          connGeom = new THREE.BufferGeometry();
          connGeom.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(positions, 3)
          );
          connGeom.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
          );
          col = connGeom.getAttribute("color");

          const lineMat = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
          });

          lines = new THREE.LineSegments(connGeom, lineMat);
          scene.add(lines);

          connections = connectionData;
          console.log(`Created ${connections.length} connections`);
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          testCube.rotation.x += 0.01;
          testCube.rotation.y += 0.01;

          // Keep the camera positioned according to spherical coordinates
          camera.position.x =
            cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
          camera.position.y = cameraDistance * Math.cos(cameraPhi);
          camera.position.z =
            cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
          camera.lookAt(cameraTarget);

          // Update neurons only while running
          if (isRunning) {
            for (let i = 0; i < neurons.length; i++) {
              const n = neurons[i],
                g = glows[i],
                u = n.userData;

              // Simulate random activity
              if (Math.random() < 0.01) {
                u.pulse = 1.2;
              }

              if (u.pulse > 0) {
                u.pulse *= 0.85;
                const intensity = u.pulse / 1.2;

                const glowColor = u.glowColor
                  .clone()
                  .multiplyScalar(intensity * 2);
                // Some materials may not have emissive; check and set if available
                if (n.material.emissive) n.material.emissive.copy(glowColor);

                n.scale.setScalar(1.0 + intensity * 0.4);
                if (g && g.material) g.material.opacity = 0.2 + intensity * 0.6;
                if (g) g.scale.setScalar(1.0 + intensity * 3.0);
              } else {
                if (n.material.emissive)
                  n.material.emissive.copy(
                    u.originalColor.clone().multiplyScalar(0.4)
                  );
                n.scale.setScalar(1.0);
                if (g && g.material) g.material.opacity = 0.15;
                if (g) g.scale.setScalar(1.0);
              }
            }
          }

          renderer.render(scene, camera);
          console.log("Rendering frame");
        }

        // Message handling (stub)
        function handleMessage(e) {
          // WebSocket message handling would go here
        }

        // Initialize everything
        createNetworkTopology();

        // Add mouse controls
        let mouseX = 0,
          mouseY = 0;
        let isMouseDown = false;

        function onMouseMove(event) {
          if (isMouseDown) {
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;

            // Rotate camera around scene
            cameraTheta += deltaX * 0.01;
            cameraPhi += deltaY * 0.01;
            cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));

            camera.position.x =
              cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.y = cameraDistance * Math.cos(cameraPhi);
            camera.position.z =
              cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            camera.lookAt(cameraTarget);
          }

          mouseX = event.clientX;
          mouseY = event.clientY;
        }

        function onMouseDown(event) {
          // Only start dragging if the click is not on a UI element
          if (
            event.target.closest(
              "#hud, #panel, #controls, #info, #lessonPanel, #navControls, #neuronInfo, #lessonModal"
            )
          ) {
            return;
          }
          isMouseDown = true;
          mouseX = event.clientX;
          mouseY = event.clientY;
        }

        function onMouseUp(event) {
          isMouseDown = false;
        }

        function onMouseWheel(event) {
          cameraDistance += event.deltaY * 0.1;
          cameraDistance = Math.max(10, Math.min(200, cameraDistance));

          camera.position.x =
            cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);
          camera.position.y = cameraDistance * Math.cos(cameraPhi);
          camera.position.z =
            cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
          camera.lookAt(cameraTarget);
        }

        // Add event listeners (attached to window so UI remains interactive)
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mousedown", onMouseDown);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("wheel", onMouseWheel);

        // UI controls - with robust null checks
        const playBtn = document.getElementById("play");
        const resetBtn = document.getElementById("resetNetwork");
        const showWeightsBtn = document.getElementById("showWeights");
        const networkSizeSlider = document.getElementById("networkSize");
        const inputSlider = document.getElementById("inputCurrent");
        const weightSlider = document.getElementById("synapseWeight");
        const lessonSelect = document.getElementById("lessonSelect");
        const prevLesson = document.getElementById("prevLesson");
        const nextLesson = document.getElementById("nextLesson");
        const viewLesson = document.getElementById("viewLesson");
        const lessonModal = document.getElementById("lessonModal");
        const closeModal = document.getElementById("closeModal");

        if (playBtn) {
          playBtn.addEventListener("click", () => {
            isRunning = !isRunning;
            playBtn.classList.toggle("on", isRunning);
            playBtn.textContent = isRunning ? "Pause" : "Play";
          });
        }

        if (resetBtn) {
          resetBtn.addEventListener("click", () => {
            createNetworkTopology();
          });
        }

        if (showWeightsBtn) {
          showWeightsBtn.addEventListener("click", () => {
            showWeights = !showWeights;
            if (lines && lines.material) {
              lines.material.visible = showWeights;
            }
            showWeightsBtn.classList.toggle("on", showWeights);
          });
        }

        if (networkSizeSlider) {
          networkSizeSlider.addEventListener("input", (e) => {
            const sizeValueEl = document.getElementById("sizeValue");
            if (sizeValueEl) sizeValueEl.textContent = e.target.value;
          });
          networkSizeSlider.addEventListener("change", () => {
            createNetworkTopology();
          });
        }

        if (inputSlider) {
          inputSlider.addEventListener("input", (e) => {
            const inputValueEl = document.getElementById("inputValue");
            if (inputValueEl) inputValueEl.textContent = e.target.value;
          });
        }

        if (weightSlider) {
          weightSlider.addEventListener("input", (e) => {
            const weightValueEl = document.getElementById("weightValue");
            if (weightValueEl) weightValueEl.textContent = e.target.value;
          });
        }

        if (prevLesson && lessonSelect) {
          prevLesson.addEventListener("click", () => {
            lessonSelect.selectedIndex = Math.max(
              0,
              lessonSelect.selectedIndex - 1
            );
          });
        }

        if (nextLesson && lessonSelect) {
          nextLesson.addEventListener("click", () => {
            lessonSelect.selectedIndex = Math.min(
              lessonSelect.options.length - 1,
              lessonSelect.selectedIndex + 1
            );
          });
        }

        if (viewLesson && lessonModal && lessonSelect) {
          viewLesson.addEventListener("click", () => {
            const lessonFrame = document.getElementById("lessonFrame");
            lessonModal.style.display = "block";
            if (lessonFrame) {
              lessonFrame.srcdoc =
                "<h2>" +
                lessonSelect.options[lessonSelect.selectedIndex].text +
                "</h2>";
            }
          });
        }

        if (closeModal && lessonModal) {
          closeModal.addEventListener("click", () => {
            const lessonFrame = document.getElementById("lessonFrame");
            lessonModal.style.display = "none";
            if (lessonFrame) lessonFrame.src = "";
          });
        }

        connectWS();
        animate();

        console.log("Neural network initialized successfully!");
      }

      // Start when page loads
      document.addEventListener("DOMContentLoaded", initNeuralNetwork);
    </script>
  </body>
</html>
