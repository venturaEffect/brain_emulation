<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SNN Visualizer — SYNTHETIC-2</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--bg:#0a0c12;--panel:#12151c;--text:#c4d1e0;--muted:#6b7280;--edge:#1e293b;--edgeHot:#3b82f6;--node:#60a5fa;--hot:#f59e0b;--pulse:#ef4444}
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:14px/1.5 Inter,system-ui,Helvetica,Arial;overflow:hidden}
    canvas{display:block}
    #overlay{pointer-events:none;position:fixed;inset:0;background:
      radial-gradient(1400px 900px at 30% 0%, #1e293b22, transparent 70%),
      radial-gradient(1000px 600px at 80% 100%, #1e1b4b22, transparent 60%);}    
    #hud{position:fixed;left:20px;top:20px;display:flex;gap:14px;align-items:center;background:rgba(18,21,28,0.85);padding:12px 16px;border-radius:16px;border:1px solid #1e293b;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);box-shadow:0 8px 25px rgba(0,0,0,0.4)}
    .btn{border:1px solid rgba(255,255,255,0.06);border-radius:12px;background:rgba(12,8,18,0.9);color:#f3f2ff;cursor:pointer;padding:10px 14px;transition:all 0.12s ease;box-shadow:0 2px 8px rgba(0,0,0,0.6)}
    .btn:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(0,0,0,0.6)}
    .btn.on{background:#ff00d6;color:#06010a;border-color:rgba(255,0,214,0.35);box-shadow:0 0 18px rgba(255,0,214,0.12)}
    .range{accent-color:#ff00d6}
    #panel{position:fixed;right:20px;top:20px;width:300px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5)}
    #panel h4{margin:0 0 8px;font-weight:600;color:#f1f5f9;font-size:15px}
    #trace{width:100%;height:150px;background:#0f172a;border-radius:12px;border:1px solid #1e293b}
    #err{position:fixed;left:20px;bottom:20px;background:#dc2626;color:#fff;padding:10px 14px;border-radius:12px;display:none}
    #controls{position:fixed;left:20px;bottom:20px;width:300px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);max-height:300px;overflow-y:auto}
    .control-group{margin-bottom:12px}
    .control-group label{display:block;margin-bottom:4px;font-size:13px;color:#94a3b8}
    .control-group input[type="range"]{width:100%;accent-color:#3b82f6}
    .toggle{background:#1e293b;border:1px solid #334155;padding:6px 12px;border-radius:8px;cursor:pointer;display:inline-block;margin:2px}
    .toggle.active{background:#1e40af;color:#fff}
    #info{position:fixed;right:20px;bottom:20px;width:320px;background:var(--panel);border:1px solid #1e293b;border-radius:16px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,0.5);font-size:13px;line-height:1.6}
    .lesson{background:#0f172a;padding:12px;border-radius:8px;margin:8px 0;border-left:3px solid #3b82f6}

    /* Panel borders and consistent dark panels */
    #hud, #panel, #controls, #info, #lessonPanel, #lessonModal > div {
      background: #0b0c0f;
      border: 1px solid rgba(200,200,200,0.06); /* very thin grey border */
    }

    /* Neon buttons and active state */
    .btn {
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(12,8,18,0.9); /* dark base */
      color: #f3f2ff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      transition: all 0.12s ease;
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
    }
    .btn.on {
      background: #ff00d6; /* neon magenta */
      color: #06010a;
      border-color: rgba(255,0,214,0.35);
      box-shadow: 0 0 18px rgba(255,0,214,0.12);
    }

    /* Range neon accent (magenta) */
    .range { 
      accent-color: #ff00d6; 
    }
    input[type="range"]::-webkit-slider-thumb{
      background: #ff00d6;
      box-shadow: 0 0 8px rgba(255,0,214,0.18);
      border: 1px solid rgba(255,255,255,0.08);
    }
    input[type="range"]::-moz-range-thumb{
      background: #ff00d6;
      box-shadow: 0 0 8px rgba(255,0,214,0.18);
      border: 1px solid rgba(255,255,255,0.08);
    }

    /* Lesson full content: make text clear and ensure background transparent/dark + neon title */
    #lessonFullContent { color: #e6e9ef; background: transparent; }
    #lessonFullContent h1, #lessonFullContent h2, #lessonFullContent h3, #lessonFullContent strong {
      background: transparent !important;
      color: #ff9bf0 !important; /* neon magenta title color */
      margin: 0 0 8px 0;
    }
    /* Small lesson card title emphasis */
    .lesson strong { color: #ff9bf0; }

    /* Lesson iframe (full lesson) */
    #lessonModal > div { overflow: hidden; }
    #lessonFrame {
      width: 100%;
      height: 60vh;
      border: none;
      border-radius: 10px;
      background: transparent;
      display: block;
    }
    #lessonFallback { padding: 12px 0; color: #cbd5e1; line-height:1.6; }
  </style>
</head>
<body>
<div id="overlay"></div>
<div id="hud">
  <div style="font-weight:600;color:#f1f5f9">SNN • Neural Network</div>
  <button id="play" class="btn on">Pause</button>
  <label style="color:#94a3b8">Speed <input id="speed" class="range" type="range" min="10" max="150" value="50"/></label>
</div>

<div id="panel">
  <h4 id="sel">Select Neuron</h4>
  <div style="margin-bottom:8px;font-size:12px;color:#94a3b8">
    Voltage: <span id="voltageValue" style="color:#f223e0;font-weight:bold">--</span>
    <span style="margin-left:10px">Threshold: <span style="color:#60a5fa">1.0</span></span>
  </div>
  <canvas id="trace" width="260" height="150"></canvas>
</div>

<!-- Re-added lesson panel (restore missing settings UI) -->
<div id="lessonPanel" style="position:fixed;left:20px;top:80px;display:flex;gap:12px;align-items:center;background:rgba(18,21,28,0.85);padding:10px 16px;border-radius:12px;border:1px solid #1e293b;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);box-shadow:0 8px 25px rgba(0,0,0,0.4)">
  <label for="lessonSelect" style="color:#94a3b8;font-weight:500;">Lesson:</label>
  <select id="lessonSelect">
    <option value="1">Lesson 1: Basic Spike Dynamics</option>
    <option value="2">Lesson 2: Synaptic Transmission</option>
    <option value="3">Lesson 3: Network Plasticity</option>
    <option value="4">Lesson 4: Pattern Recognition</option>
  </select>
  <div style="display:flex;gap:8px;">
    <button id="prevLesson" class="btn" style="padding:6px 10px;font-size:12px;">← Prev</button>
    <button id="nextLesson" class="btn" style="padding:6px 10px;font-size:12px;">Next →</button>
    <button id="viewLesson" class="btn" style="padding:6px 10px;font-size:12px;background:#f223e0;color:#fff;">📖 View Full</button>
  </div>
</div>

<div id="controls">
  <h4 style="margin:0 0 12px;color:#f1f5f9">Learning Controls</h4>
  <div class="control-group">
    <label>Lesson Mode:</label>
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <div class="toggle active" id="lesson1">Basic Spikes</div>
      <div class="toggle" id="lesson2">Synapses</div>
      <div class="toggle" id="lesson3">Plasticity</div>
      <div class="toggle" id="lesson4">Patterns</div>
    </div>
  </div>

  <div class="control-group">
    <label for="inputCurrent">Input Current: <span id="inputValue">0.5</span></label>
    <input type="range" id="inputCurrent" min="0" max="2" step="0.1" value="0.5"/>
  </div>

  <div class="control-group">
    <label for="synapseWeight">Synaptic Weight: <span id="weightValue">0.2</span></label>
    <input type="range" id="synapseWeight" min="0" max="1" step="0.05" value="0.2"/>
  </div>

  <div class="control-group">
    <label for="networkSize">Network Size: <span id="sizeValue">50</span></label>
    <input type="range" id="networkSize" min="10" max="100" step="5" value="50"/>
  </div>

  <div class="control-group">
    <label for="connectionProb">Connection Probability: <span id="probValue">0.045</span></label>
    <input type="range" id="connectionProb" min="0" max="0.2" step="0.005" value="0.045"/>
  </div>

  <button id="resetNetwork" class="btn">Reset Network</button>
  <button id="showWeights" class="btn">Show Weights</button>

  <div class="control-group" id="patternControls" style="display:none;">
    <button id="injectPattern" class="btn" style="width:100%;margin-bottom:8px;">Inject Pattern</button>
    <button id="testMemory" class="btn" style="width:100%;">Test Memory</button>
  </div>
</div>

<!-- Re-add lesson modal (restores ability to view full lesson) -->
<div id="lessonModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);z-index:1000;overflow-y:auto;">
  <div style="max-width:800px;margin:40px auto;background:#12151c;border:1px solid #334155;border-radius:16px;padding:18px 20px;position:relative;">
    <button id="closeModal" style="position:absolute;top:12px;right:12px;background:none;border:none;color:#94a3b8;font-size:24px;cursor:pointer;">×</button>

    <!-- iframe will load lessons/lessonX.html -->
    <iframe id="lessonFrame" src="" title="Lesson content" sandbox="allow-same-origin allow-scripts allow-forms"></iframe>

    <!-- fallback (used when iframe can't load or as graceful fallback) -->
    <div id="lessonFallback" style="display:none;">
      <!-- Full lesson content injected here when iframe unavailable -->
    </div>
  </div>
</div>

<div id="info">
  <h4 style="margin:0 0 8px;color:#f1f5f9">Learning Guide</h4>
  <div id="lessonContent">
    <div class="lesson">
      <strong>Lesson 1: Basic Spikes</strong><br>
      Each neuron accumulates voltage over time. When it reaches threshold (v=1), it fires a spike and resets to 0.
    </div>
  </div>
</div>
<div id="err"></div>

<script src="three.min.js"></script>
<script>
(function(){
  const showErr = m => {
    const e = document.getElementById('err');
    e.textContent = m;
    e.style.display = 'block';
  };
  
  if (!window.THREE) {
    showErr('Three.js missing. Please download three.min.js');
    return;
  }

  // WebSocket connection
  let ws;
  function connectWS() {
    try {
      ws = new WebSocket('ws://localhost:8766');
      ws.onopen = () => {
        console.log('Connected to SNN server');
        document.getElementById('err').style.display = 'none';
      };
      ws.onerror = () => showErr('Connection failed. Make sure server.py is running.');
      ws.onclose = () => setTimeout(connectWS, 2000);
      ws.onmessage = handleMessage;
    } catch (error) {
      showErr('Failed to connect to server');
    }
  }

  // Constants
  const NUM = 50;
  const CLUSTER_COLORS = [
    { primary: new THREE.Color(0.0, 0.8, 1.0), glow: new THREE.Color(0.3, 0.9, 1.0) },
    { primary: new THREE.Color(1.0, 0.2, 0.8), glow: new THREE.Color(1.0, 0.5, 0.9) },
    { primary: new THREE.Color(0.9, 1.0, 0.0), glow: new THREE.Color(1.0, 1.0, 0.4) },
    { primary: new THREE.Color(1.0, 0.5, 0.0), glow: new THREE.Color(1.0, 0.7, 0.3) },
    { primary: new THREE.Color(1.0, 0.0, 0.4), glow: new THREE.Color(1.0, 0.3, 0.6) }
  ];

  // Three.js setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 0, 120);
  
  const renderer = new THREE.WebGLRenderer({antialias: true, powerPreference: "high-performance"});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  scene.add(new THREE.AmbientLight(0x0a0a0a, 0.3));
  const keyLight = new THREE.PointLight(0x4080ff, 2.0, 200);
  keyLight.position.set(80, 80, 80);
  scene.add(keyLight);

  // Recreate accent lights (restores original color accents)
  const accentLights = [];
  CLUSTER_COLORS.forEach((cluster, i) => {
    const angle = (i / CLUSTER_COLORS.length) * Math.PI * 2;
    const light = new THREE.PointLight(cluster.primary.getHex(), 0.85, 200);
    light.position.set(Math.cos(angle) * 90, Math.sin(angle) * 90, Math.sin(angle * 2) * 40);
    scene.add(light);
    accentLights.push(light);
  });

  // Global variables
  const neurons = [], glows = [], connectionLabels = [];
  let connections = [];
  let connGeom, col, lines;
  let selected = null, traceBuf = [];
  let showWeights = false;

  // Create network topology
  function createNetworkTopology() {
    // Clear existing
    neurons.forEach(n => scene.remove(n));
    glows.forEach(g => scene.remove(g));
    neurons.length = 0;
    glows.length = 0;

    const radius = 35;
    const N_EXC = 40, N_INH = 10;
    
    // Create excitatory neurons
    for (let i = 0; i < N_EXC; i++) {
      const clusterId = Math.floor(i / (N_EXC / 4));
      const clusterColor = CLUSTER_COLORS[clusterId];
      
      const angleY = (i / (N_EXC / 4)) * Math.PI * 2 + clusterId * Math.PI * 0.5;
      const angleX = (Math.floor(i / (N_EXC / 3)) / 3) * Math.PI;
      const clusterRadius = radius + (Math.random() - 0.5) * 15;
      
      const position = new THREE.Vector3(
        Math.sin(angleX) * Math.cos(angleY) * clusterRadius,
        Math.cos(angleX) * clusterRadius * 0.7,
        Math.sin(angleX) * Math.sin(angleY) * clusterRadius
      );

      const geometry = new THREE.SphereGeometry(1.2, 24, 24);
      const material = new THREE.MeshStandardMaterial({
        color: clusterColor.primary,
        emissive: clusterColor.primary.clone().multiplyScalar(0.4),
        roughness: 0.3,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });

      const neuron = new THREE.Mesh(geometry, material);
      neuron.position.copy(position);
      neuron.userData = {
        id: i,
        cluster: clusterId,
        pulse: 0,
        volt: 0,
        type: 'excitatory',
        originalColor: clusterColor.primary.clone(),
        glowColor: clusterColor.glow.clone()
      };
      scene.add(neuron);
      neurons.push(neuron);

      // Glow effect
      const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: clusterColor.glow,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(position);
      scene.add(glow);
      glows.push(glow);
    }

    // Create inhibitory neurons
    for (let i = 0; i < N_INH; i++) {
      const angle = (i / N_INH) * Math.PI * 2;
      const height = (Math.random() - 0.5) * 40;
      const r = radius * 1.3;
      
      const position = new THREE.Vector3(Math.cos(angle) * r, height, Math.sin(angle) * r);

      const geometry = new THREE.SphereGeometry(1.0, 20, 20);
      const material = new THREE.MeshStandardMaterial({
        color: CLUSTER_COLORS[4].primary,
        emissive: CLUSTER_COLORS[4].primary.clone().multiplyScalar(0.4),
        roughness: 0.3,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9
      });

      const neuron = new THREE.Mesh(geometry, material);
      neuron.position.copy(position);
      neuron.userData = {
        id: i + N_EXC,
        cluster: 4,
        pulse: 0,
        volt: 0,
        type: 'inhibitory',
        originalColor: CLUSTER_COLORS[4].primary.clone(),
        glowColor: CLUSTER_COLORS[4].glow.clone()
      };
      scene.add(neuron);
      neurons.push(neuron);

      const glowGeometry = new THREE.SphereGeometry(2.0, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: CLUSTER_COLORS[4].glow,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(position);
      scene.add(glow);
      glows.push(glow);
    }

    createConnectionNetwork();
    console.log(`Created network: ${neurons.length} neurons`);
  }

  function createConnectionNetwork() {
    const positions = [];
    const colors = [];
    const connectionData = [];
    
    for (let i = 0; i < neurons.length; i++) {
      for (let j = 0; j < neurons.length; j++) {
        if (i !== j) {
          const prob = neurons[i].userData.cluster === neurons[j].userData.cluster ? 0.6 : 0.3;
          
          if (Math.random() < prob) {
            const fromPos = neurons[i].position;
            const toPos = neurons[j].position;
            
            positions.push(fromPos.x, fromPos.y, fromPos.z);
            positions.push(toPos.x, toPos.y, toPos.z);
            
            const fromCluster = neurons[i].userData.cluster;
            const color = CLUSTER_COLORS[fromCluster].primary.clone().multiplyScalar(0.4);
            
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
            
            connectionData.push({ from: i, to: j, cluster: fromCluster });
          }
        }
      }
    }
    
    connGeom = new THREE.BufferGeometry();
    connGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    connGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    col = connGeom.getAttribute('color');
    
    const lineMat = new THREE.LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    
    lines = new THREE.LineSegments(connGeom, lineMat);
    scene.add(lines);
    
    connections = connectionData;
    console.log(`Created ${connections.length} connections`);
  }

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    const clusterActivity = [0, 0, 0, 0, 0];
    
    for (let i = 0; i < neurons.length; i++) {
      const n = neurons[i], g = glows[i], u = n.userData;
      
      // Always visible base color with voltage modulation
      const voltage = Math.max(0, Math.min(1, u.volt || 0));
      const baseColor = u.originalColor.clone();
      baseColor.lerp(u.glowColor, voltage * 0.4);
      n.material.color.copy(baseColor);
      
      if (u.pulse > 0) {
        u.pulse *= 0.85;
        const intensity = u.pulse / 1.2;
        
        clusterActivity[u.cluster] += intensity;
        
        // Bright firing effects
        const glowColor = u.glowColor.clone().multiplyScalar(intensity * 2);
        n.material.emissive.copy(glowColor);
        n.scale.setScalar(1.0 + intensity * 0.4);
        
        // Enhanced glow
        g.material.opacity = 0.2 + intensity * 0.6;
        g.scale.setScalar(1.0 + intensity * 3.0);
        g.material.color.copy(u.glowColor);
        
      } else {
        // Base state - always visible
        n.material.emissive.copy(u.originalColor.clone().multiplyScalar(0.4));
        n.scale.setScalar(1.0);
        g.material.opacity = 0.15;
        g.scale.setScalar(1.0);
      }
    }
    
    // Update connection colors based on cluster activity
    if (connGeom && col && connections.length > 0) {
      for (let i = 0; i < connections.length; i++) {
        const conn = connections[i];
        const baseIdx = i * 6;
        
        if (baseIdx + 5 < col.array.length) {
          const clusterColor = CLUSTER_COLORS[conn.cluster].primary;
          const activity = clusterActivity[conn.cluster];
          
          // Always visible base + activity boost
          const baseIntensity = 0.4;
          const activityBoost = Math.min(activity * 0.8, 1.0);
          const totalIntensity = baseIntensity + activityBoost;
          
          col.array[baseIdx] = clusterColor.r * totalIntensity;
          col.array[baseIdx + 1] = clusterColor.g * totalIntensity;
          col.array[baseIdx + 2] = clusterColor.b * totalIntensity;
          col.array[baseIdx + 3] = clusterColor.r * totalIntensity;
          col.array[baseIdx + 4] = clusterColor.g * totalIntensity;
          col.array[baseIdx + 5] = clusterColor.b * totalIntensity;
        }
      }
      col.needsUpdate = true;
    }
    
    drawTrace();
    renderer.render(scene, camera);
  }

  // Message handling - FIXED to handle spikes correctly
  function handleMessage(e) {
    const d = JSON.parse(e.data);
    
    if (d.volt) {
      for (const k in d.volt) {
        const i = +k;
        if (neurons[i]) {
          neurons[i].userData.volt = d.volt[k];
          if (selected === i) {
            traceBuf.push(d.volt[k]);
            if (traceBuf.length > 200) traceBuf.shift();
          }
        }
      }
    }
    
    if (d.spikes) {
      const clusterSpikes = {};
      
      d.spikes.forEach(spike => {
        const i = spike.i;  // FIXED: spike.i not just i
        if (neurons[i]) {
          const neuron = neurons[i];
          const cluster = neuron.userData.cluster;
          
          // Set individual pulse
          neuron.userData.pulse = 1.2;
          
          // Track cluster spikes
          if (!clusterSpikes[cluster]) clusterSpikes[cluster] = [];
          clusterSpikes[cluster].push(neuron);
        }
      });
      
      // CLUSTER BURST EFFECTS
      Object.keys(clusterSpikes).forEach(clusterId => {
        const spikes = clusterSpikes[clusterId];
        if (spikes.length > 1) {
          neurons.forEach(n => {
            if (n.userData.cluster == clusterId) {
              n.userData.pulse = Math.max(n.userData.pulse, 1.5);
            }
          });
        }
      });
    }
    
    if (d.cmd === "showConnections" && d.connections) {
      updateConnectionVisualization(d.connections);
    }
  }

  // FIXED: Controls with proper WebSocket commands
  const btn = document.getElementById('play');
  const rng = document.getElementById('speed');
  
  btn.onclick = () => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    
    const isCurrentlyPaused = btn.classList.contains('on');
    
    if (isCurrentlyPaused) {
      btn.classList.remove('on');
      btn.textContent = 'Play';
      ws.send(JSON.stringify({cmd:'pause'}));
    } else {
      btn.classList.add('on');
      btn.textContent = 'Pause';
      ws.send(JSON.stringify({cmd:'play'}));
    }
  };
  
  rng.oninput = () => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const speed = parseInt(rng.value, 10);
    const dt_ms = Math.max(5, 200 - speed);
    ws.send(JSON.stringify({cmd:'speed', dt_ms: dt_ms}));
  };

  // FIXED: Input controls
  const inputCurrent = document.getElementById('inputCurrent');
  const inputValue = document.getElementById('inputValue');
  if (inputCurrent && inputValue) {
    inputCurrent.addEventListener('input', () => {
      inputValue.textContent = inputCurrent.value;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({cmd:'setInput', value: parseFloat(inputCurrent.value)}));
      }
    });
  }

  // FIXED: Reset and show weights buttons
  const resetBtn = document.getElementById('resetNetwork');
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({cmd:'reset'}));
      }
    });
  }

  const showWeightsBtn = document.getElementById('showWeights');
  if (showWeightsBtn) {
    showWeightsBtn.addEventListener('click', () => {
      showWeights = !showWeights;
      showWeightsBtn.textContent = showWeights ? 'Hide Weights' : 'Show Weights';
      showWeightsBtn.classList.toggle('on', showWeights);
      
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({cmd:'toggleWeights'}));
      }
    });
  }

  // FIXED: Trace drawing function
  function drawTrace() {
    const canvas = document.getElementById('trace');
    const c = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // clear background
    c.fillStyle = '#0f172a';
    c.fillRect(0, 0, W, H);

    // draw subtle grid lines
    c.strokeStyle = '#1e293b';
    c.lineWidth = 1;
    c.beginPath();
    for (let i = 0; i <= 4; i++) {
      const y = 8 + (i * (H - 16) / 4);
      c.moveTo(6, y);
      c.lineTo(W - 6, y);
    }
    c.stroke();

    // draw trace if available
    if (traceBuf && traceBuf.length > 0) {
      const len = Math.min(traceBuf.length, 200);
      const pad = 6;
      c.beginPath();
      c.lineWidth = 2;
      c.strokeStyle = '#60a5fa';
      for (let i = 0; i < len; i++) {
        const v = traceBuf[traceBuf.length - len + i];
        const x = pad + (i / (len - 1 || 1)) * (W - pad * 2);
        const vv = Math.max(0, Math.min(1, v));
        const y = pad + (1 - vv) * (H - pad * 2);
        if (i === 0) c.moveTo(x, y); else c.lineTo(x, y);
      }
      c.stroke();

      // latest value display
      const last = traceBuf[traceBuf.length - 1];
      c.fillStyle = '#f223e0';
      c.font = '12px Inter, system-ui, Helvetica, Arial';
      c.fillText(last !== undefined ? last.toFixed(3) : '--', 10, 14);
    } else {
      c.fillStyle = '#94a3b8';
      c.font = '12px Inter, system-ui, Helvetica, Arial';
      c.fillText('--', 10, 14);
    }
  }

  // FIXED: openLessonModal to properly load external lesson files
  function openLessonModal() {
    const modal = document.getElementById('lessonModal');
    const frame = document.getElementById('lessonFrame');
    const fallback = document.getElementById('lessonFallback');
    if (!modal || !frame || !fallback) return;

    modal.style.display = 'block';
    
    // Try to load external lesson file first
    const lessonFile = `lessons/lesson${currentLesson}.html`;
    
    // Show loading state
    fallback.style.display = 'block';
    frame.style.display = 'none';
    fallback.innerHTML = '<p style="color:#94a3b8">Loading lesson content...</p>';

    // Attempt to fetch the external lesson file
    fetch(lessonFile)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.text();
      })
      .then(html => {
        // Successfully loaded external file
        console.log(`✓ Loaded external lesson file: ${lessonFile}`);
        
        // Extract content from full HTML if needed
        let content = html;
        const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        if (bodyMatch) {
          content = bodyMatch[1];
        } else {
          const mainMatch = html.match(/<main[^>]*>([\s\S]*?)<\/main>/i);
          if (mainMatch) {
            content = mainMatch[1];
          }
        }
        
        fallback.innerHTML = content;
        fallback.style.display = 'block';
        frame.style.display = 'none';
      })
      .catch(error => {
        // Failed to load external file, use inline content
        console.log(`⚠ Could not load ${lessonFile}: ${error.message}`);
        console.log('📖 Using inline lesson content instead');
        
        // Full expanded lesson content (inline fallback)
        const fullContent = {
          1: `<h1>Lesson 1: Basic Spike Dynamics</h1>
             <h2>Overview</h2>
             <p>Neural networks are built from individual neurons that integrate electrical signals and fire action potentials (spikes) when certain conditions are met.</p>
             
             <h2>The Integrate-and-Fire Model</h2>
             <p>Each neuron in our simulation follows the leaky integrate-and-fire model:</p>
             <ul>
               <li><strong>Integration:</strong> The neuron accumulates incoming current over time</li>
               <li><strong>Threshold:</strong> When voltage reaches v=1.0, the neuron fires a spike</li>
               <li><strong>Reset:</strong> After firing, voltage resets to v=0.0</li>
               <li><strong>Leak:</strong> Voltage naturally decays toward rest without input</li>
             </ul>
             
             <h2>Detailed Dynamics</h2>
             <p>The mathematical model for each neuron follows:</p>
             <code>τ dV/dt = -V + I_input + I_noise + I_syn</code>
             
             <h2>Experiment Steps</h2>
             <p>Use the <strong>Input Current</strong> slider to see how external stimulation affects firing rates:</p>
             <ol>
               <li><strong>Low current (0.0-0.3):</strong> Sparse, irregular firing - neurons rarely reach threshold</li>
               <li><strong>Medium current (0.4-0.8):</strong> Regular firing patterns emerge - predictable spike timing</li>
               <li><strong>High current (0.9+):</strong> High-frequency bursting - rapid continuous firing</li>
             </ol>
             
             <h2>What to Observe</h2>
             <ul>
               <li>Watch how individual neurons (colored spheres) brighten when they spike</li>
               <li>Observe the voltage trace in the upper-right panel showing membrane potential</li>
               <li>Notice the relationship between input strength and firing frequency</li>
               <li>See how noise affects spike timing precision</li>
             </ul>
             
             <h2>Biological Relevance</h2>
             <p>Real neurons in the brain work similarly - they integrate synaptic inputs and fire when a threshold is reached. This simple model captures the essential dynamics of neural computation.</p>`,
             
          2: `<h1>Lesson 2: Synaptic Transmission</h1>
             <h2>How Neurons Communicate</h2>
             <p>Neurons don't work in isolation - they form networks through synaptic connections that transmit signals between cells. This lesson explores how network connectivity shapes brain function.</p>
             
             <h2>Synaptic Weights</h2>
             <p>The strength of connection between neurons is controlled by synaptic weight. This determines how much influence one neuron has on another:</p>
             <ul>
               <li><strong>Weak synapses (0.0-0.2):</strong> Subtle influence, requires many simultaneous spikes to affect the target</li>
               <li><strong>Medium synapses (0.3-0.6):</strong> Moderate influence, single spikes can noticeably change target voltage</li>
               <li><strong>Strong synapses (0.7+):</strong> Powerful influence, can trigger immediate firing in target neuron</li>
             </ul>
             
             <h2>Network Connectivity</h2>
             <p>The <strong>Connection Probability</strong> determines how densely neurons are wired together:</p>
             <ul>
               <li><strong>Sparse connectivity (0.02-0.05):</strong> Isolated activity, signals don't spread far</li>
               <li><strong>Medium connectivity (0.06-0.12):</strong> Activity spreads through network in waves</li>
               <li><strong>Dense connectivity (0.13+):</strong> Synchronized network-wide activity, all neurons fire together</li>
             </ul>
             
             <h2>Types of Synapses</h2>
             <ul>
               <li><strong>Excitatory synapses:</strong> Increase target neuron's voltage (push toward firing)</li>
               <li><strong>Inhibitory synapses:</strong> Decrease target neuron's voltage (prevent firing)</li>
             </ul>
             
             <h2>Experiment Protocol</h2>
             <ol>
               <li>Start with low synaptic weight (0.1) and sparse connectivity (0.03)</li>
               <li>Gradually increase synaptic weight - observe how activity spreads</li>
               <li>Reset and try increasing connectivity instead - compare the effects</li>
               <li>Find the "critical point" where isolated spikes become network bursts</li>
             </ol>
             
             <h2>What to Observe</h2>
             <p>Notice how the colored connections between neurons light up when activity propagates through the network. The visualization shows real-time synaptic transmission as signals flow between connected neurons.</p>`,
             
          3: `<h1>Lesson 3: Network Plasticity</h1>
             <h2>Learning and Adaptation</h2>
             <p>Real neural networks aren't static - they change their connectivity based on experience through synaptic plasticity. This is the biological basis of learning and memory.</p>
             
             <h2>Hebbian Learning Principle</h2>
             <p>The famous principle "neurons that fire together, wire together" describes how synapses strengthen:</p>
             <ul>
               <li><strong>Correlation:</strong> When pre- and post-synaptic neurons are active simultaneously</li>
               <li><strong>Strengthening:</strong> The synapse between them becomes stronger (increased weight)</li>
               <li><strong>Weakening:</strong> Unused synapses gradually weaken over time (synaptic pruning)</li>
               <li><strong>Timing matters:</strong> Precise spike timing determines whether strengthening or weakening occurs</li>
             </ul>
             
             <h2>Types of Plasticity</h2>
             <ul>
               <li><strong>Spike-Timing Dependent Plasticity (STDP):</strong> Timing of pre/post spikes matters</li>
               <li><strong>Rate-based plasticity:</strong> Overall activity levels determine changes</li>
               <li><strong>Homeostatic plasticity:</strong> Networks maintain stable overall activity</li>
             </ul>
             
             <h2>Network Reorganization</h2>
             <p>As synapses change strength, the network's behavior evolves:</p>
             <ul>
               <li>Frequently used pathways become "superhighways" for information flow</li>
               <li>Network develops preferred patterns of activity (attractors)</li>
               <li>Memory traces emerge from strengthened connection patterns</li>
               <li>Unused connections weaken and may be pruned away</li>
             </ul>
             
             <h2>Experimental Procedure</h2>
             <ol>
               <li>Reset the network to start with random connectivity</li>
               <li>Observe initial activity patterns with default settings</li>
               <li>Run for extended time and watch how patterns stabilize</li>
               <li>Use "Show Weights" to reveal current synaptic strengths</li>
               <li>Notice which connections have strengthened vs. weakened</li>
             </ol>
             
             <h2>Biological Significance</h2>
             <p>This process underlies all forms of learning - from motor skills to memories. Diseases like Alzheimer's disrupt these plasticity mechanisms, leading to memory loss.</p>`,
             
          4: `<h1>Lesson 4: Pattern Recognition and Memory</h1>
             <h2>Emergent Computation</h2>
             <p>When properly trained, neural networks can recognize patterns and recall memories from partial cues. This lesson demonstrates associative memory and pattern completion.</p>
             
             <h2>Pattern Storage Mechanism</h2>
             <p>Specific patterns of neural activity can be "stored" in the network through:</p>
             <ul>
               <li><strong>Activation Pattern:</strong> A specific subset of neurons firing together in sequence</li>
               <li><strong>Strengthened Connections:</strong> Synapses between pattern neurons become stronger through Hebbian learning</li>
               <li><strong>Memory Trace:</strong> The pattern leaves a lasting change in network connectivity</li>
               <li><strong>Distributed Storage:</strong> Memory is spread across many synapses, not localized</li>
             </ul>
             
             <h2>Pattern Recall Process</h2>
             <p>Once stored, patterns can be recalled through:</p>
             <ul>
               <li><strong>Partial Cue:</strong> Activating just part of the original pattern</li>
               <li><strong>Pattern Completion:</strong> The network fills in the missing pieces automatically</li>
               <li><strong>Attractor Dynamics:</strong> Activity converges to the nearest stored pattern</li>
               <li><strong>Content-Addressable Memory:</strong> Any part can retrieve the whole</li>
             </ul>
             
             <h2>Types of Memory Networks</h2>
             <ul>
               <li><strong>Hopfield Networks:</strong> Store fixed-point attractors</li>
               <li><strong>Associative Memory:</strong> Link different patterns together</li>
               <li><strong>Sequence Memory:</strong> Store temporal patterns and sequences</li>
             </ul>
             
             <h2>Experimental Protocol</h2>
             <ol>
               <li>Click "Inject Pattern" to store a specific activity pattern in the network</li>
               <li>Watch how the pattern spreads and strengthens connections</li>
               <li>Wait for activity to settle down</li>
               <li>Click "Test Memory" to provide a partial cue</li>
               <li>Observe whether the network recalls the full pattern</li>
               <li>Try multiple pattern injections to see interference effects</li>
             </ol>
             
             <h2>What to Observe</h2>
             <ul>
               <li>How quickly the injected pattern spreads through the network</li>
               <li>Whether the pattern becomes self-sustaining</li>
               <li>How partial cues trigger pattern completion</li>
               <li>Competition between different stored patterns</li>
               <li>The role of network connectivity in memory capacity</li>
             </ul>
             
             <h2>Real-World Applications</h2>
             <p>These principles are used in:</p>
             <ul>
               <li>Artificial neural networks for pattern recognition</li>
               <li>Associative memory systems in AI</li>
               <li>Understanding memory disorders and treatments</li>
               <li>Brain-computer interfaces</li>
             </ul>`
        };
        
        fallback.innerHTML = fullContent[currentLesson] || `<p style="color:#e6e9ef">Lesson ${currentLesson} content not available.</p>`;
        fallback.style.display = 'block';
        frame.style.display = 'none';
      });
  }

  // Initialize
  createNetworkTopology();
  connectWS();
  animate();

  // Handle window resize
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Add/update function to display connection weights and sprites when server sends connections
  function updateConnectionVisualization(conns) {
    // remove old labels
    connectionLabels.forEach(label => {
      if (label.parent) scene.remove(label);
    });
    connectionLabels.length = 0;

    if (!conns || conns.length === 0) {
      // restore subtle base connection color if needed
      if (connGeom && col) {
        const colors = connGeom.getAttribute('color');
        for (let i = 0; i < colors.array.length; i += 3) {
          colors.array[i] = 0.05;
          colors.array[i+1] = 0.08;
          colors.array[i+2] = 0.12;
        }
        colors.needsUpdate = true;
      }
      return;
    }

    // Build sprites for supplied connections
    if (connGeom) {
      conns.forEach((c) => {
        const from = c.from, to = c.to;
        if (from >= 0 && to >= 0 && from < neurons.length && to < neurons.length) {
          const fromPos = neurons[from].position;
          const toPos = neurons[to].position;
          const mid = new THREE.Vector3().addVectors(fromPos, toPos).multiplyScalar(0.5);

          const canvas = document.createElement('canvas');
          canvas.width = 160; canvas.height = 44;
          const ctx = canvas.getContext('2d');

          // dark panel background (semi-opaque) with thin grey border
          const pad = 4, w = canvas.width - pad*2, h = canvas.height - pad*2, r = 8;
          ctx.fillStyle = '#0b0c0f'; // dark
          roundRect(ctx, pad, pad, w, h, r, true, false);
          ctx.strokeStyle = 'rgba(200,200,200,0.25)';
          ctx.lineWidth = 1;
          roundRect(ctx, pad, pad, w, h, r, false, true);

          // neon small bar (magenta) to left
          const barColor = (c.type === 'inhibitory') ? '#ff416c' : '#ff00d6';
          ctx.fillStyle = barColor;
          const barW = Math.max(16, Math.min(96, (c.weight || 0) * 96));
          ctx.fillRect(pad+8, pad+8, barW, 12);

          // weight text: light on dark
          ctx.fillStyle = '#eef2ff';
          ctx.font = 'bold 12px Inter, system-ui, Helvetica, Arial';
          ctx.textAlign = 'right';
          ctx.fillText((c.weight || 0).toFixed(3), canvas.width - pad - 8, pad + 28);

          const tex = new THREE.CanvasTexture(canvas);
          tex.minFilter = THREE.LinearFilter;
          const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
          const sprite = new THREE.Sprite(spriteMat);

          // render on top so labels don't get occluded by neurons/lines
          sprite.material.depthTest = false;
          sprite.renderOrder = 999;
          sprite.position.copy(mid);
          sprite.scale.set(6.2, 1.7, 1.0);
          scene.add(sprite);
          connectionLabels.push(sprite);
        }
      });
    }
  }

  // Lesson content and modal helpers
  const lessonContent = {
    1: { title: "Basic Spike Dynamics", content: `<h1>Lesson 1: Basic Spike Dynamics</h1><p>Each neuron integrates input until threshold (v=1). When threshold is reached, it emits a spike and resets.</p>` },
    2: { title: "Synaptic Transmission", content: `<h1>Lesson 2: Synaptic Transmission</h1><p>Synapses transmit spikes between neurons. Excitatory synapses increase post-synaptic voltage; inhibitory synapses decrease it.</p>` },
    3: { title: "Network Plasticity", content: `<h1>Lesson 3: Network Plasticity</h1><p>Plasticity mechanisms change synaptic strengths over time. This lesson demonstrates simplified plastic changes: repeated co-activation can strengthen connections.</p>` },
    4: { title: "Pattern Recognition", content: `<h1>Lesson 4: Pattern Recognition</h1><p>Inject patterns and test partial cues for recall. Use <strong>Inject Pattern</strong> and <strong>Test Memory</strong> to experiment with pattern completion.</p>` }
  };
  let currentLesson = 1;

  // SINGLE openLessonModal function - removed duplicates
  function openLessonModal() {
    const modal = document.getElementById('lessonModal');
    const frame = document.getElementById('lessonFrame');
    const fallback = document.getElementById('lessonFallback');
    if (!modal || !frame || !fallback) return;

    modal.style.display = 'block';
    
    // Try to load external lesson file first
    const lessonFile = `lessons/lesson${currentLesson}.html`;
    
    // Show loading state
    fallback.style.display = 'block';
    frame.style.display = 'none';
    fallback.innerHTML = '<p style="color:#94a3b8">Loading lesson content...</p>';

    // Attempt to fetch the external lesson file
    fetch(lessonFile)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.text();
      })
      .then(html => {
        // Successfully loaded external file
        console.log(`✓ Loaded external lesson file: ${lessonFile}`);
        
        // Extract content from full HTML if needed
        let content = html;
        const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        if (bodyMatch) {
          content = bodyMatch[1];
        } else {
          const mainMatch = html.match(/<main[^>]*>([\s\S]*?)<\/main>/i);
          if (mainMatch) {
            content = mainMatch[1];
          }
        }
        
        fallback.innerHTML = content;
        fallback.style.display = 'block';
        frame.style.display = 'none';
      })
      .catch(error => {
        // Failed to load external file, use inline content
        console.log(`⚠ Could not load ${lessonFile}: ${error.message}`);
        console.log('📖 Using inline lesson content instead');
        
        // Full expanded lesson content (inline fallback)
        const fullContent = {
          1: `<h1>Lesson 1: Basic Spike Dynamics</h1>
             <h2>Overview</h2>
             <p>Neural networks are built from individual neurons that integrate electrical signals and fire action potentials (spikes) when certain conditions are met.</p>
             
             <h2>The Integrate-and-Fire Model</h2>
             <p>Each neuron in our simulation follows the leaky integrate-and-fire model:</p>
             <ul>
               <li><strong>Integration:</strong> The neuron accumulates incoming current over time</li>
               <li><strong>Threshold:</strong> When voltage reaches v=1.0, the neuron fires a spike</li>
               <li><strong>Reset:</strong> After firing, voltage resets to v=0.0</li>
               <li><strong>Leak:</strong> Voltage naturally decays toward rest without input</li>
             </ul>
             
             <h2>Detailed Dynamics</h2>
             <p>The mathematical model for each neuron follows:</p>
             <code>τ dV/dt = -V + I_input + I_noise + I_syn</code>
             
             <h2>Experiment Steps</h2>
             <p>Use the <strong>Input Current</strong> slider to see how external stimulation affects firing rates:</p>
             <ol>
               <li><strong>Low current (0.0-0.3):</strong> Sparse, irregular firing - neurons rarely reach threshold</li>
               <li><strong>Medium current (0.4-0.8):</strong> Regular firing patterns emerge - predictable spike timing</li>
               <li><strong>High current (0.9+):</strong> High-frequency bursting - rapid continuous firing</li>
             </ol>
             
             <h2>What to Observe</h2>
             <ul>
               <li>Watch how individual neurons (colored spheres) brighten when they spike</li>
               <li>Observe the voltage trace in the upper-right panel showing membrane potential</li>
               <li>Notice the relationship between input strength and firing frequency</li>
               <li>See how noise affects spike timing precision</li>
             </ul>
             
             <h2>Biological Relevance</h2>
             <p>Real neurons in the brain work similarly - they integrate synaptic inputs and fire when a threshold is reached. This simple model captures the essential dynamics of neural computation.</p>`,
             
          2: `<h1>Lesson 2: Synaptic Transmission</h1>
             <h2>How Neurons Communicate</h2>
             <p>Neurons don't work in isolation - they form networks through synaptic connections that transmit signals between cells. This lesson explores how network connectivity shapes brain function.</p>
             
             <h2>Synaptic Weights</h2>
             <p>The strength of connection between neurons is controlled by synaptic weight. This determines how much influence one neuron has on another:</p>
             <ul>
               <li><strong>Weak synapses (0.0-0.2):</strong> Subtle influence, requires many simultaneous spikes to affect the target</li>
               <li><strong>Medium synapses (0.3-0.6):</strong> Moderate influence, single spikes can noticeably change target voltage</li>
               <li><strong>Strong synapses (0.7+):</strong> Powerful influence, can trigger immediate firing in target neuron</li>
             </ul>
             
             <h2>Network Connectivity</h2>
             <p>The <strong>Connection Probability</strong> determines how densely neurons are wired together:</p>
             <ul>
               <li><strong>Sparse connectivity (0.02-0.05):</strong> Isolated activity, signals don't spread far</li>
               <li><strong>Medium connectivity (0.06-0.12):</strong> Activity spreads through network in waves</li>
               <li><strong>Dense connectivity (0.13+):</strong> Synchronized network-wide activity, all neurons fire together</li>
             </ul>
             
             <h2>Types of Synapses</h2>
             <ul>
               <li><strong>Excitatory synapses:</strong> Increase target neuron's voltage (push toward firing)</li>
               <li><strong>Inhibitory synapses:</strong> Decrease target neuron's voltage (prevent firing)</li>
             </ul>
             
             <h2>Experiment Protocol</h2>
             <ol>
               <li>Start with low synaptic weight (0.1) and sparse connectivity (0.03)</li>
               <li>Gradually increase synaptic weight - observe how activity spreads</li>
               <li>Reset and try increasing connectivity instead - compare the effects</li>
               <li>Find the "critical point" where isolated spikes become network bursts</li>
             </ol>
             
             <h2>What to Observe</h2>
             <p>Notice how the colored connections between neurons light up when activity propagates through the network. The visualization shows real-time synaptic transmission as signals flow between connected neurons.</p>`,
             
          3: `<h1>Lesson 3: Network Plasticity</h1>
             <h2>Learning and Adaptation</h2>
             <p>Real neural networks aren't static - they change their connectivity based on experience through synaptic plasticity. This is the biological basis of learning and memory.</p>
             
             <h2>Hebbian Learning Principle</h2>
             <p>The famous principle "neurons that fire together, wire together" describes how synapses strengthen:</p>
             <ul>
               <li><strong>Correlation:</strong> When pre- and post-synaptic neurons are active simultaneously</li>
               <li><strong>Strengthening:</strong> The synapse between them becomes stronger (increased weight)</li>
               <li><strong>Weakening:</strong> Unused synapses gradually weaken over time (synaptic pruning)</li>
               <li><strong>Timing matters:</strong> Precise spike timing determines whether strengthening or weakening occurs</li>
             </ul>
             
             <h2>Types of Plasticity</h2>
             <ul>
               <li><strong>Spike-Timing Dependent Plasticity (STDP):</strong> Timing of pre/post spikes matters</li>
               <li><strong>Rate-based plasticity:</strong> Overall activity levels determine changes</li>
               <li><strong>Homeostatic plasticity:</strong> Networks maintain stable overall activity</li>
             </ul>
             
             <h2>Network Reorganization</h2>
             <p>As synapses change strength, the network's behavior evolves:</p>
             <ul>
               <li>Frequently used pathways become "superhighways" for information flow</li>
               <li>Network develops preferred patterns of activity (attractors)</li>
               <li>Memory traces emerge from strengthened connection patterns</li>
               <li>Unused connections weaken and may be pruned away</li>
             </ul>
             
             <h2>Experimental Procedure</h2>
             <ol>
               <li>Reset the network to start with random connectivity</li>
               <li>Observe initial activity patterns with default settings</li>
               <li>Run for extended time and watch how patterns stabilize</li>
               <li>Use "Show Weights" to reveal current synaptic strengths</li>
               <li>Notice which connections have strengthened vs. weakened</li>
             </ol>
             
             <h2>Biological Significance</h2>
             <p>This process underlies all forms of learning - from motor skills to memories. Diseases like Alzheimer's disrupt these plasticity mechanisms, leading to memory loss.</p>`,
             
          4: `<h1>Lesson 4: Pattern Recognition and Memory</h1>
             <h2>Emergent Computation</h2>
             <p>When properly trained, neural networks can recognize patterns and recall memories from partial cues. This lesson demonstrates associative memory and pattern completion.</p>
             
             <h2>Pattern Storage Mechanism</h2>
             <p>Specific patterns of neural activity can be "stored" in the network through:</p>
             <ul>
               <li><strong>Activation Pattern:</strong> A specific subset of neurons firing together in sequence</li>
               <li><strong>Strengthened Connections:</strong> Synapses between pattern neurons become stronger through Hebbian learning</li>
               <li><strong>Memory Trace:</strong> The pattern leaves a lasting change in network connectivity</li>
               <li><strong>Distributed Storage:</strong> Memory is spread across many synapses, not localized</li>
             </ul>
             
             <h2>Pattern Recall Process</h2>
             <p>Once stored, patterns can be recalled through:</p>
             <ul>
               <li><strong>Partial Cue:</strong> Activating just part of the original pattern</li>
               <li><strong>Pattern Completion:</strong> The network fills in the missing pieces automatically</li>
               <li><strong>Attractor Dynamics:</strong> Activity converges to the nearest stored pattern</li>
               <li><strong>Content-Addressable Memory:</strong> Any part can retrieve the whole</li>
             </ul>
             
             <h2>Types of Memory Networks</h2>
             <ul>
               <li><strong>Hopfield Networks:</strong> Store fixed-point attractors</li>
               <li><strong>Associative Memory:</strong> Link different patterns together</li>
               <li><strong>Sequence Memory:</strong> Store temporal patterns and sequences</li>
             </ul>
             
             <h2>Experimental Protocol</h2>
             <ol>
               <li>Click "Inject Pattern" to store a specific activity pattern in the network</li>
               <li>Watch how the pattern spreads and strengthens connections</li>
               <li>Wait for activity to settle down</li>
               <li>Click "Test Memory" to provide a partial cue</li>
               <li>Observe whether the network recalls the full pattern</li>
               <li>Try multiple pattern injections to see interference effects</li>
             </ol>
             
             <h2>What to Observe</h2>
             <ul>
               <li>How quickly the injected pattern spreads through the network</li>
               <li>Whether the pattern becomes self-sustaining</li>
               <li>How partial cues trigger pattern completion</li>
               <li>Competition between different stored patterns</li>
               <li>The role of network connectivity in memory capacity</li>
             </ul>
             
             <h2>Real-World Applications</h2>
             <p>These principles are used in:</p>
             <ul>
               <li>Artificial neural networks for pattern recognition</li>
               <li>Associative memory systems in AI</li>
               <li>Understanding memory disorders and treatments</li>
               <li>Brain-computer interfaces</li>
             </ul>`
        };
        
        fallback.innerHTML = fullContent[currentLesson] || `<p style="color:#e6e9ef">Lesson ${currentLesson} content not available.</p>`;
        fallback.style.display = 'block';
        frame.style.display = 'none';
      });
  }

  // Helper functions for lessons
  function updateLessonContent() {
    const box = document.getElementById('lessonContent');
    if (!box) return;
    const lesson = lessonContent[currentLesson];
    box.innerHTML = `<div class="lesson"><strong>Lesson ${currentLesson}: ${lesson ? lesson.title : 'N/A'}</strong><br>${lesson ? lesson.content : ''}</div>`;
  }

  function updateLessonControls() {
    const pc = document.getElementById('patternControls');
    if (pc) pc.style.display = currentLesson === 4 ? 'block' : 'none';
  }

  function updateNavigationButtons() {
    const selEl = document.getElementById('lessonSelect');
    if (selEl) selEl.value = currentLesson;
    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    if (prevBtn) prevBtn.disabled = currentLesson === 1;
    if (nextBtn) nextBtn.disabled = currentLesson === 4;
  }

  function setLesson(n) {
    currentLesson = Math.max(1, Math.min(4, n));
    updateLessonContent();
    updateLessonControls();
    updateNavigationButtons();
  }

  // Wire up all event listeners only once
  function wireEventListeners() {
    // Main controls
    const btn = document.getElementById('play');
    const rng = document.getElementById('speed');
    
    if (btn) {
      btn.onclick = () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        
        const isCurrentlyPaused = btn.classList.contains('on');
        
        if (isCurrentlyPaused) {
          btn.classList.remove('on');
          btn.textContent = 'Play';
          ws.send(JSON.stringify({cmd:'pause'}));
        } else {
          btn.classList.add('on');
          btn.textContent = 'Pause';
          ws.send(JSON.stringify({cmd:'play'}));
        }
      };
    }
    
    if (rng) {
      rng.oninput = () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const speed = parseInt(rng.value, 10);
        const dt_ms = Math.max(5, 200 - speed);
        ws.send(JSON.stringify({cmd:'speed', dt_ms: dt_ms}));
      };
    }

    // Input controls
    const inputCurrent = document.getElementById('inputCurrent');
    const inputValue = document.getElementById('inputValue');
    if (inputCurrent && inputValue) {
      inputCurrent.addEventListener('input', () => {
        inputValue.textContent = inputCurrent.value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'setInput', value: parseFloat(inputCurrent.value)}));
        }
      });
    }

    // Reset and show weights buttons
    const resetBtn = document.getElementById('resetNetwork');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'reset'}));
        }
      });
    }

    const showWeightsBtn = document.getElementById('showWeights');
    if (showWeightsBtn) {
      showWeightsBtn.addEventListener('click', () => {
        showWeights = !showWeights;
        showWeightsBtn.textContent = showWeights ? 'Hide Weights' : 'Show Weights';
        showWeightsBtn.classList.toggle('on', showWeights);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({cmd:'toggleWeights'}));
        }
      });
    }

    // Trace drawing function
    function drawTrace() {
      const canvas = document.getElementById('trace');
      const c = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;

      // clear background
      c.fillStyle = '#0f172a';
      c.fillRect(0, 0, W, H);

      // draw subtle grid lines
      c.strokeStyle = '#1e293b';
      c.lineWidth = 1;
      c.beginPath();
      for (let i = 0; i <= 4; i++) {
        const y = 8 + (i * (H - 16) / 4);
        c.moveTo(6, y);
        c.lineTo(W - 6, y);
      }
      c.stroke();

      // draw trace if available
      if (traceBuf && traceBuf.length > 0) {
        const len = Math.min(traceBuf.length, 200);
        const pad = 6;
        c.beginPath();
        c.lineWidth = 2;
        c.strokeStyle = '#60a5fa';
        for (let i = 0; i < len; i++) {
          const v = traceBuf[traceBuf.length - len + i];
          const x = pad + (i / (len - 1 || 1)) * (W - pad * 2);
          const vv = Math.max(0, Math.min(1, v));
          const y = pad + (1 - vv) * (H - pad * 2);
          if (i === 0) c.moveTo(x, y); else c.lineTo(x, y);
        }
        c.stroke();

        // latest value display
        const last = traceBuf[traceBuf.length - 1];
        c.fillStyle = '#f223e0';
        c.font = '12px Inter, system-ui, Helvetica, Arial';
        c.fillText(last !== undefined ? last.toFixed(3) : '--', 10, 14);
      } else {
        c.fillStyle = '#94a3b8';
        c.font = '12px Inter, system-ui, Helvetica, Arial';
        c.fillText('--', 10, 14);
      }
    }

    // Lesson controls
    const viewBtn = document.getElementById('viewLesson');
    if (viewBtn) viewBtn.addEventListener('click', openLessonModal);

    const closeModalBtn = document.getElementById('closeModal');
    if (closeModalBtn) {
      closeModalBtn.addEventListener('click', () => {
        const modal = document.getElementById('lessonModal');
        if (modal) modal.style.display = 'none';
      });
    }

    const prevBtn = document.getElementById('prevLesson');
    const nextBtn = document.getElementById('nextLesson');
    const sel = document.getElementById('lessonSelect');

    if (prevBtn) prevBtn.addEventListener('click', () => setLesson(currentLesson - 1));
    if (nextBtn) nextBtn.addEventListener('click', () => setLesson(currentLesson + 1));
    if (sel) sel.addEventListener('change', (e) => setLesson(parseInt(e.target.value || '1', 10)));

    // Toggle lesson buttons
    document.querySelectorAll('.toggle').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.toggle').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentLesson = parseInt(btn.id.replace('lesson','')) || 1;
        updateLessonContent();
        updateLessonControls();
        updateNavigationButtons();
      });
    });
  }

  // Initialize everything
  createNetworkTopology();
  wireEventListeners();
  updateLessonContent();
  updateLessonControls();
  updateNavigationButtons();
  connectWS();
  animate();

  // Handle window resize
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Add missing roundRect helper function for canvas drawing
  function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof radius === 'undefined') radius = 5;
    if (typeof radius === 'number') {
      radius = {tl: radius, tr: radius, br: radius, bl: radius};
    } else {
      var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
      for (var side in defaultRadius) {
        radius[side] = radius[side] || defaultRadius[side];
      }
    }
    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + width - radius.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + height - radius.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Hook missing controls: synapseWeight, connectionProb, networkSize, inject/test pattern
  const synapseSlider = document.getElementById('synapseWeight');
  if (synapseSlider) {
    synapseSlider.addEventListener('input', () => {
      const v = parseFloat(synapseSlider.value);
      const label = document.getElementById('weightValue');
      if (label) label.textContent = v.toFixed(2);
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ cmd: 'setWeight', value: v }));
      }
    });
  }

  const probSlider = document.getElementById('connectionProb');
  if (probSlider) {
    probSlider.addEventListener('input', () => {
      const v = parseFloat(probSlider.value);
      const label = document.getElementById('probValue');
      if (label) label.textContent = v.toFixed(3);
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ cmd: 'setConnectionProb', value: v }));
      }
    });
  }

  const sizeSlider = document.getElementById('networkSize');
  if (sizeSlider) {
    sizeSlider.addEventListener('input', () => {
      const v = parseInt(sizeSlider.value, 10);
      const label = document.getElementById('sizeValue');
      if (label) label.textContent = v;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ cmd: 'setNetworkSize', value: v }));
        ws.send(JSON.stringify({ cmd: 'reset' }));
      }
    });
  }

  const injectBtn = document.getElementById('injectPattern');
  if (injectBtn) injectBtn.addEventListener('click', () => { 
    if (ws && ws.readyState === WebSocket.OPEN) 
      ws.send(JSON.stringify({cmd:'injectPattern'})); 
  });

  const testBtn = document.getElementById('testMemory');
  if (testBtn) testBtn.addEventListener('click', () => { 
    if (ws && ws.readyState === WebSocket.OPEN) 
      ws.send(JSON.stringify({cmd:'testMemory'})); 
  });

  // Add the missing lesson helper functions
  function updateLessonContent() {
    const box = document.getElementById('lessonContent');
    if (!box) return;
    const lesson = lessonContent[currentLesson];
    box.innerHTML = `<div class="lesson"><strong>Lesson ${currentLesson}: ${lesson ? lesson.title : 'N/A'}</strong><br>${lesson ? lesson.content : ''}</div>`;
  }

  function updateLessonControls() {
    const pc = document.getElementById('patternControls');
    if (pc) pc.style.display = currentLesson === 4 ? 'block' : 'none';
  }

  // Wire up toggle lesson buttons
  document.querySelectorAll('.toggle').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.toggle').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentLesson = parseInt(btn.id.replace('lesson','')) || 1;
      updateLessonContent();
      updateLessonControls();
      updateNavigationButtons();
    });
  });

  // FIXED: Completely rewrite openLessonModal to ALWAYS show content
  function openLessonModal() {
    const modal = document.getElementById('lessonModal');
    const frame = document.getElementById('lessonFrame');
    const fallback = document.getElementById('lessonFallback');
    if (!modal || !frame || !fallback) return;

    modal.style.display = 'block';
    
    // Try to load external lesson file first
    const lessonFile = `lessons/lesson${currentLesson}.html`;
    
    // Show loading state
    fallback.style.display = 'block';
    frame.style.display = 'none';
    fallback.innerHTML = '<p style="color:#94a3b8">Loading lesson content...</p>';

    // Attempt to fetch the external lesson file
    fetch(lessonFile)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.text();
      })
      .then(html => {
        // Successfully loaded external file
        console.log(`✓ Loaded external lesson file: ${lessonFile}`);
        
        // Extract content from full HTML if needed
        let content = html;
        const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        if (bodyMatch) {
          content = bodyMatch[1];
        } else {
          const mainMatch = html.match(/<main[^>]*>([\s\S]*?)<\/main>/i);
          if (mainMatch) {
            content = mainMatch[1];
          }
        }
        
        fallback.innerHTML = content;
        fallback.style.display = 'block';
        frame.style.display = 'none';
      })
      .catch(error => {
        // Failed to load external file, use inline content
        console.log(`⚠ Could not load ${lessonFile}: ${error.message}`);
        console.log('📖 Using inline lesson content instead');
        
        // Full expanded lesson content (inline fallback)
        const fullContent = {
          1: `<h1>Lesson 1: Basic Spike Dynamics</h1>
             <h2>Overview</h2>
             <p>Neural networks are built from individual neurons that integrate electrical signals and fire action potentials (spikes) when certain conditions are met.</p>
             
             <h2>The Integrate-and-Fire Model</h2>
             <p>Each neuron in our simulation follows the leaky integrate-and-fire model:</p>
             <ul>
               <li><strong>Integration:</strong> The neuron accumulates incoming current over time</li>
               <li><strong>Threshold:</strong> When voltage reaches v=1.0, the neuron fires a spike</li>
               <li><strong>Reset:</strong> After firing, voltage resets to v=0.0</li>
               <li><strong>Leak:</strong> Voltage naturally decays toward rest without input</li>
             </ul>
             
             <h2>Detailed Dynamics</h2>
             <p>The mathematical model for each neuron follows:</p>
             <code>τ dV/dt = -V + I_input + I_noise + I_syn</code>
             
             <h2>Experiment Steps</h2>
             <p>Use the <strong>Input Current</strong> slider to see how external stimulation affects firing rates:</p>
             <ol>
               <li><strong>Low current (0.0-0.3):</strong> Sparse, irregular firing - neurons rarely reach threshold</li>
               <li><strong>Medium current (0.4-0.8):</strong> Regular firing patterns emerge - predictable spike timing</li>
               <li><strong>High current (0.9+):</strong> High-frequency bursting - rapid continuous firing</li>
             </ol>
             
             <h2>What to Observe</h2>
             <ul>
               <li>Watch how individual neurons (colored spheres) brighten when they spike</li>
               <li>Observe the voltage trace in the upper-right panel showing membrane potential</li>
               <li>Notice the relationship between input strength and firing frequency</li>
               <li>See how noise affects spike timing precision</li>
             </ul>
             
             <h2>Biological Relevance</h2>
             <p>Real neurons in the brain work similarly - they integrate synaptic inputs and fire when a threshold is reached. This simple model captures the essential dynamics of neural computation.</p>`,
             
          2: `<h1>Lesson 2: Synaptic Transmission</h1>
             <h2>How Neurons Communicate</h2>
             <p>Neurons don't work in isolation - they form networks through synaptic connections that transmit signals between cells. This lesson explores how network connectivity shapes brain function.</p>
             
             <h2>Synaptic Weights</h2>
             <p>The strength of connection between neurons is controlled by synaptic weight. This determines how much influence one neuron has on another:</p>
             <ul>
               <li><strong>Weak synapses (0.0-0.2):</strong> Subtle influence, requires many simultaneous spikes to affect the target</li>
               <li><strong>Medium synapses (0.3-0.6):</strong> Moderate influence, single spikes can noticeably change target voltage</li>
               <li><strong>Strong synapses (0.7+):</strong> Powerful influence, can trigger immediate firing in target neuron</li>
             </ul>
             
             <h2>Network Connectivity</h2>
             <p>The <strong>Connection Probability</strong> determines how densely neurons are wired together:</p>
             <ul>
               <li><strong>Sparse connectivity (0.02-0.05):</strong> Isolated activity, signals don't spread far</li>
               <li><strong>Medium connectivity (0.06-0.12):</strong> Activity spreads through network in waves</li>
               <li><strong>Dense connectivity (0.13+):</strong> Synchronized network-wide activity, all neurons fire together</li>
             </ul>
             
             <h2>Types of Synapses</h2>
             <ul>
               <li><strong>Excitatory synapses:</strong> Increase target neuron's voltage (push toward firing)</li>
               <li><strong>Inhibitory synapses:</strong> Decrease target neuron's voltage (prevent firing)</li>
             </ul>
             
             <h2>Experiment Protocol</h2>
             <ol>
               <li>Start with low synaptic weight (0.1) and sparse connectivity (0.03)</li>
               <li>Gradually increase synaptic weight - observe how activity spreads</li>
               <li>Reset and try increasing connectivity instead - compare the effects</li>
               <li>Find the "critical point" where isolated spikes become network bursts</li>
             </ol>
             
             <h2>What to Observe</h2>
             <p>Notice how the colored connections between neurons light up when activity propagates through the network. The visualization shows real-time synaptic transmission as signals flow between connected neurons.</p>`,
             
          3: `<h1>Lesson 3: Network Plasticity</h1>
             <h2>Learning and Adaptation</h2>
             <p>Real neural networks aren't static - they change their connectivity based on experience through synaptic plasticity. This is the biological basis of learning and memory.</p>
             
             <h2>Hebbian Learning Principle</h2>
             <p>The famous principle "neurons that fire together, wire together" describes how synapses strengthen:</p>
             <ul>
               <li><strong>Correlation:</strong> When pre- and post-synaptic neurons are active simultaneously</li>
               <li><strong>Strengthening:</strong> The synapse between them becomes stronger (increased weight)</li>
               <li><strong>Weakening:</strong> Unused synapses gradually weaken over time (synaptic pruning)</li>
               <li><strong>Timing matters:</strong> Precise spike timing determines whether strengthening or weakening occurs</li>
             </ul>
             
             <h2>Types of Plasticity</h2>
             <ul>
               <li><strong>Spike-Timing Dependent Plasticity (STDP):</strong> Timing of pre/post spikes matters</li>
               <li><strong>Rate-based plasticity:</strong> Overall activity levels determine changes</li>
               <li><strong>Homeostatic plasticity:</strong> Networks maintain stable overall activity</li>
             </ul>
             
             <h2>Network Reorganization</h2>
             <p>As synapses change strength, the network's behavior evolves:</p>
             <ul>
               <li>Frequently used pathways become "superhighways" for information flow</li>
               <li>Network develops preferred patterns of activity (attractors)</li>
               <li>Memory traces emerge from strengthened connection patterns</li>
               <li>Unused connections weaken and may be pruned away</li>
             </ul>
             
             <h2>Experimental Procedure</h2>
             <ol>
               <li>Reset the network to start with random connectivity</li>
               <li>Observe initial activity patterns with default settings</li>
               <li>Run for extended time and watch how patterns stabilize</li>
               <li>Use "Show Weights" to reveal current synaptic strengths</li>
               <li>Notice which connections have strengthened vs. weakened</li>
             </ol>
             
             <h2>Biological Significance</h2>
             <p>This process underlies all forms of learning - from motor skills to memories. Diseases like Alzheimer's disrupt these plasticity mechanisms, leading to memory loss.</p>`,
             
          4: `<h1>Lesson 4: Pattern Recognition and Memory</h1>
             <h2>Emergent Computation</h2>
             <p>When properly trained, neural networks can recognize patterns and recall memories from partial cues. This lesson demonstrates associative memory and pattern completion.</p>
             
             <h2>Pattern Storage Mechanism</h2>
             <p>Specific patterns of neural activity can be "stored" in the network through:</p>
             <ul>
               <li><strong>Activation Pattern:</strong> A specific subset of neurons firing together in sequence</li>
               <li><strong>Strengthened Connections:</strong> Synapses between pattern neurons become stronger through Hebbian learning</li>
               <li><strong>Memory Trace:</strong> The pattern leaves a lasting change in network connectivity</li>
               <li><strong>Distributed Storage:</strong> Memory is spread across many synapses, not localized</li>
             </ul>
             
             <h2>Pattern Recall Process</h2>
             <p>Once stored, patterns can be recalled through:</p>
             <ul>
               <li><strong>Partial Cue:</strong> Activating just part of the original pattern</li>
               <li><strong>Pattern Completion:</strong> The network fills in the missing pieces automatically</li>
               <li><strong>Attractor Dynamics:</strong> Activity converges to the nearest stored pattern</li>
               <li><strong>Content-Addressable Memory:</strong> Any part can retrieve the whole</li>
             </ul>
             
             <h2>Types of Memory Networks</h2>
             <ul>
               <li><strong>Hopfield Networks:</strong> Store fixed-point attractors</li>
               <li><strong>Associative Memory:</strong> Link different patterns together</li>
               <li><strong>Sequence Memory:</strong> Store temporal patterns and sequences</li>
             </ul>
             
             <h2>Experimental Protocol</h2>
             <ol>
               <li>Click "Inject Pattern" to store a specific activity pattern in the network</li>
               <li>Watch how the pattern spreads and strengthens connections</li>
               <li>Wait for activity to settle down</li>
               <li>Click "Test Memory" to provide a partial cue</li>
               <li>Observe whether the network recalls the full pattern</li>
               <li>Try multiple pattern injections to see interference effects</li>
             </ol>
             
             <h2>What to Observe</h2>
             <ul>
               <li>How quickly the injected pattern spreads through the network</li>
               <li>Whether the pattern becomes self-sustaining</li>
               <li>How partial cues trigger pattern completion</li>
               <li>Competition between different stored patterns</li>
               <li>The role of network connectivity in memory capacity</li>
             </ul>
             
             <h2>Real-World Applications</h2>
             <p>These principles are used in:</p>
             <ul>
               <li>Artificial neural networks for pattern recognition</li>
               <li>Associative memory systems in AI</li>
               <li>Understanding memory disorders and treatments</li>
               <li>Brain-computer interfaces</li>
             </ul>`
        };
        
        fallback.innerHTML = fullContent[currentLesson] || `<p style="color:#e6e9ef">Lesson ${currentLesson} content not available.</p>`;
        fallback.style.display = 'block';
        frame.style.display = 'none';
      });
  }

  // Initialize
  createNetworkTopology();
  connectWS();
  animate();

  // Handle window resize
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

})(); // end IIFE
</script>

</body>
</html>
