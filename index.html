<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>SNN Visualizer — SYNTHETIC-2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/three@0.165.0/build/three.min.js"></script>
    <script>
      // Fallback if CDN fails
      if (typeof THREE === "undefined") {
        document.write(
          '<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r165/three.min.js"><\/script>'
        );
      }
    </script>
    <style>
      :root {
        --bg: #0a0c12;
        --panel: #12151c;
        --text: #c4d1e0;
        --muted: #6b7280;
        --edge: #1e293b;
        --edgeHot: #3b82f6;
        --node: #60a5fa;
        --hot: #f59e0b;
        --pulse: #ef4444;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font: 14px/1.5 Inter, system-ui, Helvetica, Arial;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #overlay {
        pointer-events: none;
        position: fixed;
        inset: 0;
        background: radial-gradient(
            1400px 900px at 30% 0%,
            #1e293b22,
            transparent 70%
          ),
          radial-gradient(1000px 600px at 80% 100%, #1e1b4b22, transparent 60%);
      }
      #hud {
        position: fixed;
        left: 20px;
        top: 20px;
        display: flex;
        gap: 14px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 12px 16px;
        border-radius: 16px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }
      .btn {
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        background: rgba(12, 8, 18, 0.9);
        color: #f3f2ff;
        cursor: pointer;
        padding: 10px 14px;
        transition: all 0.12s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      }
      .btn.on {
        background: #ff00d6;
        color: #06010a;
        border-color: rgba(255, 0, 214, 0.35);
        box-shadow: 0 0 18px rgba(255, 0, 214, 0.12);
      }
      .range {
        accent-color: #ff00d6;
      }
      #panel {
        position: fixed;
        right: 20px;
        top: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      }
      #panel h4 {
        margin: 0 0 8px;
        font-weight: 600;
        color: #f1f5f9;
        font-size: 15px;
      }
      #trace {
        width: 100%;
        height: 150px;
        background: #0f172a;
        border-radius: 12px;
        border: 1px solid #1e293b;
      }
      #err {
        position: fixed;
        left: 20px;
        bottom: 20px;
        background: #dc2626;
        color: #fff;
        padding: 10px 14px;
        border-radius: 12px;
        display: none;
      }
      #controls {
        position: fixed;
        left: 20px;
        bottom: 20px;
        width: 300px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        max-height: calc(100vh - 40px);
        overflow-y: auto;
      }
      .control-group {
        margin-bottom: 12px;
      }
      .control-group label {
        display: block;
        margin-bottom: 4px;
        font-size: 13px;
        color: #94a3b8;
      }
      .control-group input[type="range"] {
        width: 100%;
        accent-color: #3b82f6;
      }
      .toggle {
        background: #1e293b;
        border: 1px solid #334155;
        padding: 6px 12px;
        border-radius: 8px;
        cursor: pointer;
        display: inline-block;
        margin: 2px;
      }
      .toggle.active {
        background: #1e40af;
        color: #fff;
      }
      #info {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 320px;
        background: var(--panel);
        border: 1px solid #1e293b;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        font-size: 13px;
        line-height: 1.6;
        z-index: 10;
      }
      .lesson {
        background: #0f172a;
        padding: 12px;
        border-radius: 8px;
        margin: 8px 0;
        border-left: 3px solid #3b82f6;
      }
      #lessonPanel {
        left: 20px;
        top: 80px;
        display: flex;
        gap: 12px;
        align-items: center;
        background: rgba(18, 21, 28, 0.85);
        padding: 10px 16px;
        border-radius: 12px;
        border: 1px solid #1e293b;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        position: fixed;
        z-index: 10;
      }
      #navControls {
        right: 20px;
        top: 200px;
        background: rgba(12, 8, 18, 0.9);
        border: 1px solid rgba(200, 200, 200, 0.06);
        border-radius: 12px;
        padding: 12px;
        color: #f3f2ff;
        font-size: 11px;
        line-height: 1.4;
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
        max-width: 180px;
        position: fixed;
        z-index: 10;
      }
      #navControls h5 {
        margin: 0 0 8px 0;
        color: #ff9bf0;
        font-size: 12px;
        font-weight: 600;
      }
      .nav-tip {
        margin: 4px 0;
        color: #94a3b8;
      }
      #three-canvas {
        position: fixed;
        inset: 0;
        z-index: 0;
        cursor: grab;
      }
      #three-canvas:active {
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <canvas id="three-canvas"></canvas>
    <div id="overlay"></div>

    <!-- TOP BAR -->
    <div id="hud">
      <div style="font-weight: 600; color: #f1f5f9">SNN • Neural Network</div>
      <button id="play" class="btn on">Pause</button>
      <label style="color: #94a3b8"
        >Speed
        <input
          id="speed"
          class="range"
          type="range"
          min="0.1"
          max="5"
          step="0.1"
          value="1"
        />
      </label>
    </div>

    <!-- LESSONS BAR -->
    <div id="lessonPanel">
      <label for="lessonSelect" style="color: #94a3b8; font-weight: 500"
        >Lesson:</label
      >
      <select id="lessonSelect">
        <option value="1">Lesson 1: Basic Spike Dynamics</option>
        <option value="2">Lesson 2: Synaptic Transmission</option>
        <option value="3">Lesson 3: Network Plasticity</option>
        <option value="4">Lesson 4: Pattern Recognition</option>
      </select>
    </div>

    <!-- LEFT CONTROLS -->
    <div id="controls">
      <h4 style="margin: 0 0 12px; color: #f1f5f9">Learning Controls</h4>
      <div class="control-group">
        <label for="networkSize"
          >Network Size: <span id="sizeValue">50</span></label
        >
        <input
          type="range"
          id="networkSize"
          min="10"
          max="200"
          step="5"
          value="50"
        />
      </div>
      <div class="control-group">
        <label for="connectionProb"
          >Connection Probability: <span id="probValue">0.10</span></label
        >
        <input
          type="range"
          id="connectionProb"
          min="0"
          max="0.5"
          step="0.01"
          value="0.10"
        />
      </div>
      <button id="resetNetwork" class="btn">Reset Network</button>
      <button id="showWeights" class="btn">Show Weights</button>
    </div>

    <!-- RIGHT INFO -->
    <div id="panel">
      <h4 id="sel">Select Neuron</h4>
      <div style="margin-bottom: 8px; font-size: 12px; color: #94a3b8">
        Voltage:
        <span id="voltageValue" style="color: #f223e0; font-weight: bold"
          >--</span
        >
        <span style="margin-left: 10px"
          >Threshold: <span style="color: #60a5fa">1.0</span></span
        >
      </div>
      <canvas id="trace" width="260" height="150"></canvas>
    </div>

    <div id="navControls">
      <h5>🎮 Fly Controls</h5>
      <div class="nav-tip"><strong>L-Click Drag:</strong> Rotate</div>
      <div class="nav-tip"><strong>R-Click Drag:</strong> Pan</div>
      <div class="nav-tip"><strong>WASD:</strong> Move</div>
      <div class="nav-tip"><strong>Q/E:</strong> Up/Down</div>
      <div class="nav-tip"><strong>Wheel:</strong> Zoom</div>
      <div class="nav-tip"><strong>Space:</strong> Reset View</div>
    </div>

    <div id="info">
      <h4 style="margin: 0 0 8px; color: #f1f5f9">Learning Guide</h4>
      <div id="lessonContent">
        <div class="lesson">
          <strong>Lesson 1: Basic Spikes</strong><br />
          Each neuron accumulates voltage over time. When it reaches threshold
          (v=1), it fires a spike and resets to 0.
        </div>
      </div>
    </div>

    <div id="err"></div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        "use strict";

        // Check if THREE.js is loaded
        if (typeof THREE === "undefined") {
          console.error("THREE.js failed to load");
          const errEl = document.getElementById("err");
          errEl.textContent =
            "THREE.js library failed to load. Please check your internet connection.";
          errEl.style.display = "block";
          return;
        }

        // --- CONFIG & STATE ---
        const state = {
          isRunning: true,
          showWeights: false,
          speed: 1,
        };

        const config = {
          networkSize: 50,
          connectionProb: 0.1,
          neuronSize: 1.0,
          pulseIntensity: 1.5,
          cameraMoveSpeed: 0.2,
        };

        const CLUSTER_COLORS = [
          {
            primary: new THREE.Color(0.0, 0.8, 1.0),
            glow: new THREE.Color(0.3, 0.9, 1.0),
          },
          {
            primary: new THREE.Color(1.0, 0.2, 0.8),
            glow: new THREE.Color(1.0, 0.5, 0.9),
          },
          {
            primary: new THREE.Color(0.9, 1.0, 0.0),
            glow: new THREE.Color(1.0, 1.0, 0.4),
          },
          {
            primary: new THREE.Color(1.0, 0.5, 0.0),
            glow: new THREE.Color(1.0, 0.7, 0.3),
          },
        ];

        // --- DOM ELEMENTS ---
        const dom = {
          canvas: document.getElementById("three-canvas"),
          playBtn: document.getElementById("play"),
          speedSlider: document.getElementById("speed"),
          networkSizeSlider: document.getElementById("networkSize"),
          sizeValueLabel: document.getElementById("sizeValue"),
          connectionProbSlider: document.getElementById("connectionProb"),
          probValueLabel: document.getElementById("probValue"),
          resetBtn: document.getElementById("resetNetwork"),
          showWeightsBtn: document.getElementById("showWeights"),
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0c12);
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        const renderer = new THREE.WebGLRenderer({
          canvas: dom.canvas,
          antialias: true,
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        scene.add(new THREE.AmbientLight(0x404040, 1.5));
        const keyLight = new THREE.PointLight(0x60a5fa, 2.0, 300);
        keyLight.position.set(50, 50, 50);
        scene.add(keyLight);

        // --- CAMERA CONTROLS ---
        const cameraControls = {
          target: new THREE.Vector3(0, 0, 0),
          distance: 100,
          theta: 1.5,
          phi: 1.5,
          move: { forward: 0, right: 0, up: 0 },
          mouse: { x: 0, y: 0, isLeftDown: false, isRightDown: false },

          init() {
            dom.canvas.addEventListener("mousedown", (e) =>
              this.onMouseDown(e)
            );
            window.addEventListener("mouseup", (e) => this.onMouseUp(e));
            window.addEventListener("mousemove", (e) => this.onMouseMove(e));
            dom.canvas.addEventListener("wheel", (e) => this.onWheel(e));
            dom.canvas.addEventListener("contextmenu", (e) =>
              e.preventDefault()
            );
            window.addEventListener("keydown", (e) => this.onKeyDown(e));
            window.addEventListener("keyup", (e) => this.onKeyUp(e));
            this.update();
          },
          onMouseDown(e) {
            if (e.button === 0) this.mouse.isLeftDown = true;
            if (e.button === 2) this.mouse.isRightDown = true;
          },
          onMouseUp(e) {
            if (e.button === 0) this.mouse.isLeftDown = false;
            if (e.button === 2) this.mouse.isRightDown = false;
          },
          onMouseMove(e) {
            const dx = e.clientX - this.mouse.x;
            const dy = e.clientY - this.mouse.y;
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;

            if (this.mouse.isLeftDown) {
              this.theta -= dx * 0.005;
              this.phi -= dy * 0.005;
              this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi));
            }
            if (this.mouse.isRightDown) {
              const right = new THREE.Vector3()
                .setFromMatrixColumn(camera.matrix, 0)
                .multiplyScalar(-dx * 0.1);
              const up = new THREE.Vector3()
                .setFromMatrixColumn(camera.matrix, 1)
                .multiplyScalar(dy * 0.1);
              this.target.add(right).add(up);
            }
          },
          onWheel(e) {
            this.distance += e.deltaY * 0.1;
            this.distance = Math.max(5, Math.min(500, this.distance));
          },
          onKeyDown(e) {
            if (e.code === "KeyW") this.move.forward = 1;
            if (e.code === "KeyS") this.move.forward = -1;
            if (e.code === "KeyD") this.move.right = 1;
            if (e.code === "KeyA") this.move.right = -1;
            if (e.code === "KeyE") this.move.up = 1;
            if (e.code === "KeyQ") this.move.up = -1;
            if (e.code === "Space") this.reset();
          },
          onKeyUp(e) {
            if (e.code === "KeyW" || e.code === "KeyS") this.move.forward = 0;
            if (e.code === "KeyA" || e.code === "KeyD") this.move.right = 0;
            if (e.code === "KeyQ" || e.code === "KeyE") this.move.up = 0;
          },
          update() {
            const forwardDir = new THREE.Vector3();
            camera.getWorldDirection(forwardDir);
            const rightDir = new THREE.Vector3()
              .crossVectors(camera.up, forwardDir)
              .normalize();

            this.target.add(
              forwardDir.multiplyScalar(
                this.move.forward * config.cameraMoveSpeed * state.speed
              )
            );
            this.target.add(
              rightDir.multiplyScalar(
                this.move.right * config.cameraMoveSpeed * state.speed
              )
            );
            this.target.y +=
              this.move.up * config.cameraMoveSpeed * state.speed;

            camera.position.x =
              this.target.x +
              this.distance * Math.sin(this.phi) * Math.cos(this.theta);
            camera.position.y =
              this.target.y + this.distance * Math.cos(this.phi);
            camera.position.z =
              this.target.z +
              this.distance * Math.sin(this.phi) * Math.sin(this.theta);
            camera.lookAt(this.target);
          },
          reset() {
            this.target.set(0, 0, 0);
            this.distance = 100;
            this.theta = 1.5;
            this.phi = 1.5;
          },
        };
        cameraControls.init();

        // --- NETWORK ---
        const network = {
          neurons: [],
          glows: [],
          lines: null,

          create() {
            this.destroy();
            const radius = 40;
            for (let i = 0; i < config.networkSize; i++) {
              const clusterId = Math.floor(i / (config.networkSize / 4));
              const c = CLUSTER_COLORS[clusterId % CLUSTER_COLORS.length];
              const pos = new THREE.Vector3(
                (Math.random() - 0.5) * radius * 2,
                (Math.random() - 0.5) * radius * 2,
                (Math.random() - 0.5) * radius * 2
              );

              const neuron = new THREE.Mesh(
                new THREE.SphereGeometry(config.neuronSize, 24, 12),
                new THREE.MeshLambertMaterial({
                  color: c.primary,
                  emissive: c.primary.clone().multiplyScalar(0.5),
                })
              );
              neuron.position.copy(pos);
              neuron.userData = {
                id: i,
                pulse: 0,
                originalColor: c.primary,
                glowColor: c.glow,
              };
              this.neurons.push(neuron);
              scene.add(neuron);

              const glow = new THREE.Mesh(
                new THREE.SphereGeometry(config.neuronSize * 1.8, 24, 12),
                new THREE.MeshBasicMaterial({
                  color: c.glow,
                  transparent: true,
                  opacity: 0.3,
                  blending: THREE.AdditiveBlending,
                })
              );
              glow.position.copy(pos);
              this.glows.push(glow);
              scene.add(glow);
            }
            this.createConnections();
          },

          createConnections() {
            const positions = [];
            const colors = [];
            for (let i = 0; i < this.neurons.length; i++) {
              for (let j = i + 1; j < this.neurons.length; j++) {
                if (Math.random() < config.connectionProb) {
                  positions.push(
                    ...this.neurons[i].position.toArray(),
                    ...this.neurons[j].position.toArray()
                  );
                  const c = this.neurons[i].userData.originalColor
                    .clone()
                    .multiplyScalar(0.4);
                  colors.push(c.r, c.g, c.b, c.r, c.g, c.b);
                }
              }
            }
            const geom = new THREE.BufferGeometry();
            geom.setAttribute(
              "position",
              new THREE.Float32BufferAttribute(positions, 3)
            );
            geom.setAttribute(
              "color",
              new THREE.Float32BufferAttribute(colors, 3)
            );
            const mat = new THREE.LineBasicMaterial({
              vertexColors: true,
              transparent: true,
              opacity: 0.2,
              blending: THREE.AdditiveBlending,
            });
            this.lines = new THREE.LineSegments(geom, mat);
            this.lines.visible = state.showWeights;
            scene.add(this.lines);
          },

          update() {
            for (let i = 0; i < this.neurons.length; i++) {
              const n = this.neurons[i],
                g = this.glows[i],
                u = n.userData;
              if (Math.random() < 0.001 * state.speed)
                u.pulse = config.pulseIntensity;

              if (u.pulse > 0.01) {
                u.pulse *= 0.95; // Decay
                const intensity = u.pulse / config.pulseIntensity;
                n.material.emissive.copy(
                  u.glowColor.clone().multiplyScalar(intensity * 1.5)
                );
                n.scale.setScalar(1 + intensity * 0.8);
                g.material.opacity = Math.max(0.3, intensity * 1.2);
                g.scale.setScalar(1 + intensity * 2.5);
              } else {
                n.material.emissive.copy(
                  u.originalColor.clone().multiplyScalar(0.5)
                );
                n.scale.setScalar(1.0);
                g.material.opacity = 0.3;
                g.scale.setScalar(1.0);
              }
            }
          },

          destroy() {
            this.neurons.forEach((n) => scene.remove(n));
            this.glows.forEach((g) => scene.remove(g));
            if (this.lines) scene.remove(this.lines);
            this.neurons.length = 0;
            this.glows.length = 0;
          },
        };

        // --- UI BINDINGS ---
        function bindUI() {
          dom.playBtn.addEventListener("click", () => {
            state.isRunning = !state.isRunning;
            dom.playBtn.textContent = state.isRunning ? "Pause" : "Play";
            dom.playBtn.classList.toggle("on", state.isRunning);
          });
          dom.speedSlider.addEventListener(
            "input",
            (e) => (state.speed = parseFloat(e.target.value))
          );
          dom.networkSizeSlider.addEventListener("input", (e) => {
            config.networkSize = parseInt(e.target.value);
            dom.sizeValueLabel.textContent = config.networkSize;
          });
          dom.networkSizeSlider.addEventListener("change", () =>
            network.create()
          );
          dom.connectionProbSlider.addEventListener("input", (e) => {
            config.connectionProb = parseFloat(e.target.value);
            dom.probValueLabel.textContent = config.connectionProb.toFixed(2);
          });
          dom.connectionProbSlider.addEventListener("change", () =>
            network.create()
          );
          dom.resetBtn.addEventListener("click", () => network.create());
          dom.showWeightsBtn.addEventListener("click", () => {
            state.showWeights = !state.showWeights;
            network.lines.visible = state.showWeights;
            dom.showWeightsBtn.classList.toggle("on", state.showWeights);
          });
        }

        // --- MAIN LOOP ---
        function animate() {
          requestAnimationFrame(animate);
          cameraControls.update();
          if (state.isRunning) {
            network.update();
          }
          renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        bindUI();
        network.create();
        animate();
      });
    </script>
  </body>
</html>
